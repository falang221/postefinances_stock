# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE username = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'username': 'ggciceaie',
                'name': 'bbehjachib',
                'password': 'cadfabfehe',
                'role': enums.UserRole.CHEF_SERVICE,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'username': 'dgiiaaijj',
                    'name': 'bfaiacjjfc',
                    'password': 'eigcfgbif',
                    'role': enums.UserRole.CHEF_SERVICE,
                },
                {
                    # data to create a User record
                    'username': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'password': 'biabhbdai',
                    'role': enums.UserRole.CHEF_SERVICE,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'idghgaicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'fjfddhigg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the email field
        users = await User.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the name field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the password field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'cbbbjbfcii',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bbejhfidcb',
            },
            data={
                'create': {
                    'id': 'bbejhfidcb',
                    'username': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'password': 'biabhbdai',
                    'role': enums.UserRole.CHEF_SERVICE,
                },
                'update': {
                    'username': 'bagcfbhiig',
                    'name': 'cghideieh',
                    'password': 'biabhbdai',
                    'role': enums.UserRole.CHEF_SERVICE,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'role': enums.UserRole.CHEF_SERVICE
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'department': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'refreshToken': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by createdAt values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RequestActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Request]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Request.prisma().query_raw(
            'SELECT * FROM Request WHERE id = $1',
            'bgeecijdgg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Request
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Request.prisma().query_first(
            'SELECT * FROM Request WHERE requestNumber = $1',
            'bdiicjafbj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RequestCreateInput,
        include: Optional[types.RequestInclude] = None
    ) -> _PrismaModelT:
        """Create a new Request record.

        Parameters
        ----------
        data
            Request record data
        include
            Specifies which relations should be loaded on the returned Request model

        Returns
        -------
        prisma.models.Request
            The created Request record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Request record from just the required fields
        request = await Request.prisma().create(
            data={
                # data to create a Request record
                'requesterId': 'bgehebiafc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RequestCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Request records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Request record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Request.prisma().create_many(
            data=[
                {
                    # data to create a Request record
                    'requesterId': 'bghffegacj',
                },
                {
                    # data to create a Request record
                    'requesterId': 'bhghchehcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RequestWhereUniqueInput,
        include: Optional[types.RequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Request record.

        Parameters
        ----------
        where
            Request filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Request model

        Returns
        -------
        prisma.models.Request
            The deleted Request record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        request = await Request.prisma().delete(
            where={
                'id': 'dcgchcbbf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RequestWhereUniqueInput,
        include: Optional[types.RequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Request record.

        Parameters
        ----------
        where
            Request filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Request model

        Returns
        -------
        prisma.models.Request
            The found Request record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        request = await Request.prisma().find_unique(
            where={
                'id': 'bdedcabahc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RequestWhereUniqueInput,
        include: Optional[types.RequestInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Request record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Request filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Request model

        Returns
        -------
        prisma.models.Request
            The found Request record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        request = await Request.prisma().find_unique_or_raise(
            where={
                'id': 'ghfhiafcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RequestWhereInput] = None,
        cursor: Optional[types.RequestWhereUniqueInput] = None,
        include: Optional[types.RequestInclude] = None,
        order: Optional[Union[types.RequestOrderByInput, List[types.RequestOrderByInput]]] = None,
        distinct: Optional[List[types.RequestScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Request records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Request records returned
        skip
            Ignore the first N results
        where
            Request filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Request model
        order
            Order the returned Request records by any field
        distinct
            Filter Request records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Request]
            The list of all Request records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Request records
        requests = await Request.prisma().find_many(take=10)

        # find the first 5 Request records ordered by the status field
        requests = await Request.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RequestWhereInput] = None,
        cursor: Optional[types.RequestWhereUniqueInput] = None,
        include: Optional[types.RequestInclude] = None,
        order: Optional[Union[types.RequestOrderByInput, List[types.RequestOrderByInput]]] = None,
        distinct: Optional[List[types.RequestScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Request record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Request filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Request model
        order
            Order the returned Request records by any field
        distinct
            Filter Request records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Request
            The first Request record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Request record ordered by the requesterObservations field
        request = await Request.prisma().find_first(
            skip=1,
            order={
                'requesterObservations': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RequestWhereInput] = None,
        cursor: Optional[types.RequestWhereUniqueInput] = None,
        include: Optional[types.RequestInclude] = None,
        order: Optional[Union[types.RequestOrderByInput, List[types.RequestOrderByInput]]] = None,
        distinct: Optional[List[types.RequestScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Request record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Request filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Request model
        order
            Order the returned Request records by any field
        distinct
            Filter Request records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Request
            The first Request record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Request record ordered by the requesterId field
        request = await Request.prisma().find_first_or_raise(
            skip=1,
            order={
                'requesterId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RequestUpdateInput,
        where: types.RequestWhereUniqueInput,
        include: Optional[types.RequestInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Request record.

        Parameters
        ----------
        data
            Request record data specifying what to update
        where
            Request filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Request model

        Returns
        -------
        prisma.models.Request
            The updated Request record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        request = await Request.prisma().update(
            where={
                'id': 'heejgedji',
            },
            data={
                # data to update the Request record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RequestWhereUniqueInput,
        data: types.RequestUpsertInput,
        include: Optional[types.RequestInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Request filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Request model

        Returns
        -------
        prisma.models.Request
            The created or updated Request record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        request = await Request.prisma().upsert(
            where={
                'id': 'bjgjgibgbf',
            },
            data={
                'create': {
                    'id': 'bjgjgibgbf',
                    'requesterId': 'bhghchehcc',
                },
                'update': {
                    'requesterId': 'bhghchehcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RequestUpdateManyMutationInput,
        where: types.RequestWhereInput,
    ) -> int:
        """Update multiple Request records

        Parameters
        ----------
        data
            Request data to update the selected Request records to
        where
            Filter to select the Request records to update

        Returns
        -------
        int
            The total number of Request records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Request records
        total = await Request.prisma().update_many(
            data={
                'approvedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RequestWhereInput] = None,
        cursor: Optional[types.RequestWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Request records present in the database

        Parameters
        ----------
        select
            Select the Request fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Request filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RequestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Request.prisma().count()

        # results: prisma.types.RequestCountAggregateOutput
        results = await Request.prisma().count(
            select={
                '_all': True,
                'approvedById': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RequestCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RequestWhereInput] = None,
        cursor: Optional[types.RequestWhereUniqueInput] = None,
    ) -> types.RequestCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RequestCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RequestWhereInput] = None,
        cursor: Optional[types.RequestWhereUniqueInput] = None,
    ) -> Union[int, types.RequestCountAggregateOutput]:
        """Count the number of Request records present in the database

        Parameters
        ----------
        select
            Select the Request fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Request filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RequestCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Request.prisma().count()

        # results: prisma.types.RequestCountAggregateOutput
        results = await Request.prisma().count(
            select={
                '_all': True,
                'receivedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RequestCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RequestWhereInput] = None
    ) -> int:
        """Delete multiple Request records.

        Parameters
        ----------
        where
            Optional Request filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Request records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Request records
        total = await Request.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RequestScalarFieldKeys'],
        *,
        where: Optional['types.RequestWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RequestAvgAggregateInput'] = None,
        sum: Optional['types.RequestSumAggregateInput'] = None,
        min: Optional['types.RequestMinAggregateInput'] = None,
        max: Optional['types.RequestMaxAggregateInput'] = None,
        having: Optional['types.RequestScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RequestCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RequestScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RequestScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RequestGroupByOutput']:
        """Group Request records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Request fields to group records by
        where
            Request filter to select records
        take
            Limit the maximum number of Request records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RequestGroupByOutput]
            A list of dictionaries representing the Request record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Request records by receivedById values
        # and count how many records are in each group
        results = await Request.prisma().group_by(
            ['receivedById'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RequestItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RequestItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RequestItem.prisma().query_raw(
            'SELECT * FROM RequestItem WHERE id = $1',
            'bbbgbhfjge',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RequestItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RequestItem.prisma().query_first(
            'SELECT * FROM RequestItem WHERE requestId = $1',
            'igbehcbab',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RequestItemCreateInput,
        include: Optional[types.RequestItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new RequestItem record.

        Parameters
        ----------
        data
            RequestItem record data
        include
            Specifies which relations should be loaded on the returned RequestItem model

        Returns
        -------
        prisma.models.RequestItem
            The created RequestItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RequestItem record from just the required fields
        requestitem = await RequestItem.prisma().create(
            data={
                # data to create a RequestItem record
                'requestId': 'bdadaadhag',
                'productId': 'bgiggdidbf',
                'requestedQty': 2000430152,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RequestItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RequestItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RequestItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RequestItem.prisma().create_many(
            data=[
                {
                    # data to create a RequestItem record
                    'requestId': 'bigibebcib',
                    'productId': 'bigaiehgcc',
                    'requestedQty': 1448521415,
                },
                {
                    # data to create a RequestItem record
                    'requestId': 'bgcigfahea',
                    'productId': 'bcejgaggif',
                    'requestedQty': 835903122,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RequestItemWhereUniqueInput,
        include: Optional[types.RequestItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RequestItem record.

        Parameters
        ----------
        where
            RequestItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RequestItem model

        Returns
        -------
        prisma.models.RequestItem
            The deleted RequestItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        requestitem = await RequestItem.prisma().delete(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RequestItemWhereUniqueInput,
        include: Optional[types.RequestItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RequestItem record.

        Parameters
        ----------
        where
            RequestItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RequestItem model

        Returns
        -------
        prisma.models.RequestItem
            The found RequestItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        requestitem = await RequestItem.prisma().find_unique(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RequestItemWhereUniqueInput,
        include: Optional[types.RequestItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RequestItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RequestItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RequestItem model

        Returns
        -------
        prisma.models.RequestItem
            The found RequestItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        requestitem = await RequestItem.prisma().find_unique_or_raise(
            where={
                'id': 'bhhfibbigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RequestItemWhereInput] = None,
        cursor: Optional[types.RequestItemWhereUniqueInput] = None,
        include: Optional[types.RequestItemInclude] = None,
        order: Optional[Union[types.RequestItemOrderByInput, List[types.RequestItemOrderByInput]]] = None,
        distinct: Optional[List[types.RequestItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RequestItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RequestItem records returned
        skip
            Ignore the first N results
        where
            RequestItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RequestItem model
        order
            Order the returned RequestItem records by any field
        distinct
            Filter RequestItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RequestItem]
            The list of all RequestItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RequestItem records
        requestitems = await RequestItem.prisma().find_many(take=10)

        # find the first 5 RequestItem records ordered by the productId field
        requestitems = await RequestItem.prisma().find_many(
            take=5,
            order={
                'productId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RequestItemWhereInput] = None,
        cursor: Optional[types.RequestItemWhereUniqueInput] = None,
        include: Optional[types.RequestItemInclude] = None,
        order: Optional[Union[types.RequestItemOrderByInput, List[types.RequestItemOrderByInput]]] = None,
        distinct: Optional[List[types.RequestItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RequestItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RequestItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RequestItem model
        order
            Order the returned RequestItem records by any field
        distinct
            Filter RequestItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RequestItem
            The first RequestItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RequestItem record ordered by the requestedQty field
        requestitem = await RequestItem.prisma().find_first(
            skip=1,
            order={
                'requestedQty': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RequestItemWhereInput] = None,
        cursor: Optional[types.RequestItemWhereUniqueInput] = None,
        include: Optional[types.RequestItemInclude] = None,
        order: Optional[Union[types.RequestItemOrderByInput, List[types.RequestItemOrderByInput]]] = None,
        distinct: Optional[List[types.RequestItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RequestItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RequestItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RequestItem model
        order
            Order the returned RequestItem records by any field
        distinct
            Filter RequestItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RequestItem
            The first RequestItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RequestItem record ordered by the approvedQty field
        requestitem = await RequestItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'approvedQty': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RequestItemUpdateInput,
        where: types.RequestItemWhereUniqueInput,
        include: Optional[types.RequestItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RequestItem record.

        Parameters
        ----------
        data
            RequestItem record data specifying what to update
        where
            RequestItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RequestItem model

        Returns
        -------
        prisma.models.RequestItem
            The updated RequestItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        requestitem = await RequestItem.prisma().update(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                # data to update the RequestItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RequestItemWhereUniqueInput,
        data: types.RequestItemUpsertInput,
        include: Optional[types.RequestItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RequestItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RequestItem model

        Returns
        -------
        prisma.models.RequestItem
            The created or updated RequestItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        requestitem = await RequestItem.prisma().upsert(
            where={
                'id': 'jjfeafhfj',
            },
            data={
                'create': {
                    'id': 'jjfeafhfj',
                    'requestId': 'bgcigfahea',
                    'productId': 'bcejgaggif',
                    'requestedQty': 835903122,
                },
                'update': {
                    'requestId': 'bgcigfahea',
                    'productId': 'bcejgaggif',
                    'requestedQty': 835903122,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RequestItemUpdateManyMutationInput,
        where: types.RequestItemWhereInput,
    ) -> int:
        """Update multiple RequestItem records

        Parameters
        ----------
        data
            RequestItem data to update the selected RequestItem records to
        where
            Filter to select the RequestItem records to update

        Returns
        -------
        int
            The total number of RequestItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RequestItem records
        total = await RequestItem.prisma().update_many(
            data={
                'itemDisputeReason': enums.DisputeReason.QUANTITE_INCORRECTE
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RequestItemWhereInput] = None,
        cursor: Optional[types.RequestItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RequestItem records present in the database

        Parameters
        ----------
        select
            Select the RequestItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RequestItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RequestItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RequestItem.prisma().count()

        # results: prisma.types.RequestItemCountAggregateOutput
        results = await RequestItem.prisma().count(
            select={
                '_all': True,
                'itemDisputeComment': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RequestItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RequestItemWhereInput] = None,
        cursor: Optional[types.RequestItemWhereUniqueInput] = None,
    ) -> types.RequestItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RequestItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RequestItemWhereInput] = None,
        cursor: Optional[types.RequestItemWhereUniqueInput] = None,
    ) -> Union[int, types.RequestItemCountAggregateOutput]:
        """Count the number of RequestItem records present in the database

        Parameters
        ----------
        select
            Select the RequestItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RequestItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RequestItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RequestItem.prisma().count()

        # results: prisma.types.RequestItemCountAggregateOutput
        results = await RequestItem.prisma().count(
            select={
                '_all': True,
                'itemDisputeStatus': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RequestItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RequestItemWhereInput] = None
    ) -> int:
        """Delete multiple RequestItem records.

        Parameters
        ----------
        where
            Optional RequestItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RequestItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RequestItem records
        total = await RequestItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RequestItemScalarFieldKeys'],
        *,
        where: Optional['types.RequestItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RequestItemAvgAggregateInput'] = None,
        sum: Optional['types.RequestItemSumAggregateInput'] = None,
        min: Optional['types.RequestItemMinAggregateInput'] = None,
        max: Optional['types.RequestItemMaxAggregateInput'] = None,
        having: Optional['types.RequestItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RequestItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RequestItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RequestItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RequestItemGroupByOutput']:
        """Group RequestItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RequestItem fields to group records by
        where
            RequestItem filter to select records
        take
            Limit the maximum number of RequestItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RequestItemGroupByOutput]
            A list of dictionaries representing the RequestItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RequestItem records by createdAt values
        # and count how many records are in each group
        results = await RequestItem.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ApprovalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Approval]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Approval.prisma().query_raw(
            'SELECT * FROM Approval WHERE id = $1',
            'cbachdgfce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Approval
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Approval.prisma().query_first(
            'SELECT * FROM Approval WHERE requestId = $1',
            'chbfcacbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ApprovalCreateInput,
        include: Optional[types.ApprovalInclude] = None
    ) -> _PrismaModelT:
        """Create a new Approval record.

        Parameters
        ----------
        data
            Approval record data
        include
            Specifies which relations should be loaded on the returned Approval model

        Returns
        -------
        prisma.models.Approval
            The created Approval record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Approval record from just the required fields
        approval = await Approval.prisma().create(
            data={
                # data to create a Approval record
                'requestId': 'efggddide',
                'userId': 'caficfigfb',
                'role': enums.UserRole.CHEF_SERVICE,
                'decision': enums.ApprovalDecision.PROPOSITION,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ApprovalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Approval records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Approval record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Approval.prisma().create_many(
            data=[
                {
                    # data to create a Approval record
                    'requestId': 'bfidgijfjc',
                    'userId': 'ihieecagf',
                    'role': enums.UserRole.CHEF_SERVICE,
                    'decision': enums.ApprovalDecision.PROPOSITION,
                },
                {
                    # data to create a Approval record
                    'requestId': 'bghfciaafe',
                    'userId': 'bgchfhgceh',
                    'role': enums.UserRole.CHEF_SERVICE,
                    'decision': enums.ApprovalDecision.PROPOSITION,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ApprovalWhereUniqueInput,
        include: Optional[types.ApprovalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Approval record.

        Parameters
        ----------
        where
            Approval filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Approval model

        Returns
        -------
        prisma.models.Approval
            The deleted Approval record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        approval = await Approval.prisma().delete(
            where={
                'id': 'cafeiaccbc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ApprovalWhereUniqueInput,
        include: Optional[types.ApprovalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Approval record.

        Parameters
        ----------
        where
            Approval filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Approval model

        Returns
        -------
        prisma.models.Approval
            The found Approval record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        approval = await Approval.prisma().find_unique(
            where={
                'id': 'gaddfhfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ApprovalWhereUniqueInput,
        include: Optional[types.ApprovalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Approval record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Approval filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Approval model

        Returns
        -------
        prisma.models.Approval
            The found Approval record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        approval = await Approval.prisma().find_unique_or_raise(
            where={
                'id': 'gieegcbeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApprovalWhereInput] = None,
        cursor: Optional[types.ApprovalWhereUniqueInput] = None,
        include: Optional[types.ApprovalInclude] = None,
        order: Optional[Union[types.ApprovalOrderByInput, List[types.ApprovalOrderByInput]]] = None,
        distinct: Optional[List[types.ApprovalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Approval records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Approval records returned
        skip
            Ignore the first N results
        where
            Approval filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Approval model
        order
            Order the returned Approval records by any field
        distinct
            Filter Approval records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Approval]
            The list of all Approval records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Approval records
        approvals = await Approval.prisma().find_many(take=10)

        # find the first 5 Approval records ordered by the userId field
        approvals = await Approval.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ApprovalWhereInput] = None,
        cursor: Optional[types.ApprovalWhereUniqueInput] = None,
        include: Optional[types.ApprovalInclude] = None,
        order: Optional[Union[types.ApprovalOrderByInput, List[types.ApprovalOrderByInput]]] = None,
        distinct: Optional[List[types.ApprovalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Approval record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Approval filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Approval model
        order
            Order the returned Approval records by any field
        distinct
            Filter Approval records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Approval
            The first Approval record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Approval record ordered by the role field
        approval = await Approval.prisma().find_first(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ApprovalWhereInput] = None,
        cursor: Optional[types.ApprovalWhereUniqueInput] = None,
        include: Optional[types.ApprovalInclude] = None,
        order: Optional[Union[types.ApprovalOrderByInput, List[types.ApprovalOrderByInput]]] = None,
        distinct: Optional[List[types.ApprovalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Approval record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Approval filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Approval model
        order
            Order the returned Approval records by any field
        distinct
            Filter Approval records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Approval
            The first Approval record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Approval record ordered by the decision field
        approval = await Approval.prisma().find_first_or_raise(
            skip=1,
            order={
                'decision': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ApprovalUpdateInput,
        where: types.ApprovalWhereUniqueInput,
        include: Optional[types.ApprovalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Approval record.

        Parameters
        ----------
        data
            Approval record data specifying what to update
        where
            Approval filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Approval model

        Returns
        -------
        prisma.models.Approval
            The updated Approval record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        approval = await Approval.prisma().update(
            where={
                'id': 'bgcffadich',
            },
            data={
                # data to update the Approval record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ApprovalWhereUniqueInput,
        data: types.ApprovalUpsertInput,
        include: Optional[types.ApprovalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Approval filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Approval model

        Returns
        -------
        prisma.models.Approval
            The created or updated Approval record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        approval = await Approval.prisma().upsert(
            where={
                'id': 'fcbichhci',
            },
            data={
                'create': {
                    'id': 'fcbichhci',
                    'requestId': 'bghfciaafe',
                    'userId': 'bgchfhgceh',
                    'role': enums.UserRole.CHEF_SERVICE,
                    'decision': enums.ApprovalDecision.PROPOSITION,
                },
                'update': {
                    'requestId': 'bghfciaafe',
                    'userId': 'bgchfhgceh',
                    'role': enums.UserRole.CHEF_SERVICE,
                    'decision': enums.ApprovalDecision.PROPOSITION,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ApprovalUpdateManyMutationInput,
        where: types.ApprovalWhereInput,
    ) -> int:
        """Update multiple Approval records

        Parameters
        ----------
        data
            Approval data to update the selected Approval records to
        where
            Filter to select the Approval records to update

        Returns
        -------
        int
            The total number of Approval records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Approval records
        total = await Approval.prisma().update_many(
            data={
                'comment': 'bcggadccgf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApprovalWhereInput] = None,
        cursor: Optional[types.ApprovalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Approval records present in the database

        Parameters
        ----------
        select
            Select the Approval fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Approval filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ApprovalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Approval.prisma().count()

        # results: prisma.types.ApprovalCountAggregateOutput
        results = await Approval.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ApprovalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApprovalWhereInput] = None,
        cursor: Optional[types.ApprovalWhereUniqueInput] = None,
    ) -> types.ApprovalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ApprovalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApprovalWhereInput] = None,
        cursor: Optional[types.ApprovalWhereUniqueInput] = None,
    ) -> Union[int, types.ApprovalCountAggregateOutput]:
        """Count the number of Approval records present in the database

        Parameters
        ----------
        select
            Select the Approval fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Approval filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ApprovalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Approval.prisma().count()

        # results: prisma.types.ApprovalCountAggregateOutput
        results = await Approval.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ApprovalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ApprovalWhereInput] = None
    ) -> int:
        """Delete multiple Approval records.

        Parameters
        ----------
        where
            Optional Approval filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Approval records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Approval records
        total = await Approval.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ApprovalScalarFieldKeys'],
        *,
        where: Optional['types.ApprovalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ApprovalAvgAggregateInput'] = None,
        sum: Optional['types.ApprovalSumAggregateInput'] = None,
        min: Optional['types.ApprovalMinAggregateInput'] = None,
        max: Optional['types.ApprovalMaxAggregateInput'] = None,
        having: Optional['types.ApprovalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ApprovalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ApprovalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ApprovalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ApprovalGroupByOutput']:
        """Group Approval records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Approval fields to group records by
        where
            Approval filter to select records
        take
            Limit the maximum number of Approval records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ApprovalGroupByOutput]
            A list of dictionaries representing the Approval record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Approval records by requestId values
        # and count how many records are in each group
        results = await Approval.prisma().group_by(
            ['requestId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProductActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Product]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Product.prisma().query_raw(
            'SELECT * FROM Product WHERE id = $1',
            'jdcfdcgc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Product
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Product.prisma().query_first(
            'SELECT * FROM Product WHERE name = $1',
            'cafdaehjid',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProductCreateInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Create a new Product record.

        Parameters
        ----------
        data
            Product record data
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created Product record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Product record from just the required fields
        product = await Product.prisma().create(
            data={
                # data to create a Product record
                'name': 'gifdddbia',
                'reference': 'bchehecef',
                'categoryId': 'jeijcbhfe',
                'unit': 'bjgejjabff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProductCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Product records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Product record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Product.prisma().create_many(
            data=[
                {
                    # data to create a Product record
                    'name': 'bcciijbibg',
                    'reference': 'cffcachfd',
                    'categoryId': 'bccdfhdigc',
                    'unit': 'febcgjbfj',
                },
                {
                    # data to create a Product record
                    'name': 'bageiegghg',
                    'reference': 'faidicegb',
                    'categoryId': 'bacecgfhbe',
                    'unit': 'ihcahiead',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Product record.

        Parameters
        ----------
        where
            Product filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The deleted Product record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().delete(
            where={
                'id': 'biheheiajg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Product record.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique(
            where={
                'id': 'jbgijghgb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Product record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique_or_raise(
            where={
                'id': 'hgjcghfbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Product records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N results
        where
            Product filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Product]
            The list of all Product records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Product records
        products = await Product.prisma().find_many(take=10)

        # find the first 5 Product records ordered by the reference field
        products = await Product.prisma().find_many(
            take=5,
            order={
                'reference': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Product record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the categoryId field
        product = await Product.prisma().find_first(
            skip=1,
            order={
                'categoryId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Product record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the quantity field
        product = await Product.prisma().find_first_or_raise(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProductUpdateInput,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Product record.

        Parameters
        ----------
        data
            Product record data specifying what to update
        where
            Product filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The updated Product record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        product = await Product.prisma().update(
            where={
                'id': 'icadbcehj',
            },
            data={
                # data to update the Product record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProductWhereUniqueInput,
        data: types.ProductUpsertInput,
        include: Optional[types.ProductInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Product filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created or updated Product record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().upsert(
            where={
                'id': 'jchciaee',
            },
            data={
                'create': {
                    'id': 'jchciaee',
                    'name': 'bageiegghg',
                    'reference': 'faidicegb',
                    'categoryId': 'bacecgfhbe',
                    'unit': 'ihcahiead',
                },
                'update': {
                    'name': 'bageiegghg',
                    'reference': 'faidicegb',
                    'categoryId': 'bacecgfhbe',
                    'unit': 'ihcahiead',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProductUpdateManyMutationInput,
        where: types.ProductWhereInput,
    ) -> int:
        """Update multiple Product records

        Parameters
        ----------
        data
            Product data to update the selected Product records to
        where
            Filter to select the Product records to update

        Returns
        -------
        int
            The total number of Product records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Product records
        total = await Product.prisma().update_many(
            data={
                'minStock': 344858293
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'cost': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProductCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> types.ProductCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProductCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> Union[int, types.ProductCountAggregateOutput]:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'unit': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProductCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProductWhereInput] = None
    ) -> int:
        """Delete multiple Product records.

        Parameters
        ----------
        where
            Optional Product filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Product records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Product records
        total = await Product.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProductScalarFieldKeys'],
        *,
        where: Optional['types.ProductWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProductAvgAggregateInput'] = None,
        sum: Optional['types.ProductSumAggregateInput'] = None,
        min: Optional['types.ProductMinAggregateInput'] = None,
        max: Optional['types.ProductMaxAggregateInput'] = None,
        having: Optional['types.ProductScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProductCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProductScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProductScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProductGroupByOutput']:
        """Group Product records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Product fields to group records by
        where
            Product filter to select records
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProductGroupByOutput]
            A list of dictionaries representing the Product record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Product records by location values
        # and count how many records are in each group
        results = await Product.prisma().group_by(
            ['location'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Category]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Category.prisma().query_raw(
            'SELECT * FROM Category WHERE id = $1',
            'bbcbhebbda',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Category
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Category.prisma().query_first(
            'SELECT * FROM Category WHERE name = $1',
            'bejfijgcfb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CategoryCreateInput,
        include: Optional[types.CategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Category record.

        Parameters
        ----------
        data
            Category record data
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The created Category record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Category record from just the required fields
        category = await Category.prisma().create(
            data={
                # data to create a Category record
                'name': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Category records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Category record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Category.prisma().create_many(
            data=[
                {
                    # data to create a Category record
                    'name': 'igaibbfgj',
                },
                {
                    # data to create a Category record
                    'name': 'bggajdcbbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Category record.

        Parameters
        ----------
        where
            Category filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The deleted Category record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().delete(
            where={
                'id': 'fcfhgbjed',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Category record.

        Parameters
        ----------
        where
            Category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The found Category record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().find_unique(
            where={
                'id': 'hdgcajhjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Category record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The found Category record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().find_unique_or_raise(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Category records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Category records returned
        skip
            Ignore the first N results
        where
            Category filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Category]
            The list of all Category records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Category records
        categorys = await Category.prisma().find_many(take=10)

        # find the first 5 Category records ordered by the id field
        categorys = await Category.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Category record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Category
            The first Category record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Category record ordered by the name field
        category = await Category.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Category record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Category
            The first Category record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Category record ordered by the id field
        category = await Category.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CategoryUpdateInput,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Category record.

        Parameters
        ----------
        data
            Category record data specifying what to update
        where
            Category filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The updated Category record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        category = await Category.prisma().update(
            where={
                'id': 'gdjgigfgc',
            },
            data={
                # data to update the Category record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CategoryWhereUniqueInput,
        data: types.CategoryUpsertInput,
        include: Optional[types.CategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Category filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The created or updated Category record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = await Category.prisma().upsert(
            where={
                'id': 'gfeaahdeh',
            },
            data={
                'create': {
                    'id': 'gfeaahdeh',
                    'name': 'bggajdcbbi',
                },
                'update': {
                    'name': 'bggajdcbbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CategoryUpdateManyMutationInput,
        where: types.CategoryWhereInput,
    ) -> int:
        """Update multiple Category records

        Parameters
        ----------
        data
            Category data to update the selected Category records to
        where
            Filter to select the Category records to update

        Returns
        -------
        int
            The total number of Category records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Category records
        total = await Category.prisma().update_many(
            data={
                'name': 'bjafcgbffc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Category records present in the database

        Parameters
        ----------
        select
            Select the Category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Category.prisma().count()

        # results: prisma.types.CategoryCountAggregateOutput
        results = await Category.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> types.CategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> Union[int, types.CategoryCountAggregateOutput]:
        """Count the number of Category records present in the database

        Parameters
        ----------
        select
            Select the Category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Category.prisma().count()

        # results: prisma.types.CategoryCountAggregateOutput
        results = await Category.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CategoryWhereInput] = None
    ) -> int:
        """Delete multiple Category records.

        Parameters
        ----------
        where
            Optional Category filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Category records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Category records
        total = await Category.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CategoryScalarFieldKeys'],
        *,
        where: Optional['types.CategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CategoryAvgAggregateInput'] = None,
        sum: Optional['types.CategorySumAggregateInput'] = None,
        min: Optional['types.CategoryMinAggregateInput'] = None,
        max: Optional['types.CategoryMaxAggregateInput'] = None,
        having: Optional['types.CategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CategoryGroupByOutput']:
        """Group Category records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Category fields to group records by
        where
            Category filter to select records
        take
            Limit the maximum number of Category records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CategoryGroupByOutput]
            A list of dictionaries representing the Category record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Category records by id values
        # and count how many records are in each group
        results = await Category.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TransactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Transaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Transaction.prisma().query_raw(
            'SELECT * FROM Transaction WHERE id = $1',
            'hihegjif',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Transaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Transaction.prisma().query_first(
            'SELECT * FROM Transaction WHERE productId = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TransactionCreateInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Transaction record.

        Parameters
        ----------
        data
            Transaction record data
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created Transaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Transaction record from just the required fields
        transaction = await Transaction.prisma().create(
            data={
                # data to create a Transaction record
                'productId': 'ifgaaagff',
                'userId': 'befcddgjce',
                'type': enums.TransactionType.ENTREE,
                'quantity': 1573199653,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TransactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Transaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Transaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Transaction.prisma().create_many(
            data=[
                {
                    # data to create a Transaction record
                    'productId': 'cabdjadaji',
                    'userId': 'faajgfadf',
                    'type': enums.TransactionType.ENTREE,
                    'quantity': 1800624392,
                },
                {
                    # data to create a Transaction record
                    'productId': 'cahhaghecf',
                    'userId': 'bghcbbcidi',
                    'type': enums.TransactionType.ENTREE,
                    'quantity': 926677639,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Transaction record.

        Parameters
        ----------
        where
            Transaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The deleted Transaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().delete(
            where={
                'id': 'beehgcebbg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Transaction record.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique(
            where={
                'id': 'bhdiaidiaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Transaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique_or_raise(
            where={
                'id': 'deajegcfi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Transaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N results
        where
            Transaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Transaction]
            The list of all Transaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Transaction records
        transactions = await Transaction.prisma().find_many(take=10)

        # find the first 5 Transaction records ordered by the userId field
        transactions = await Transaction.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Transaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the type field
        transaction = await Transaction.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Transaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the source field
        transaction = await Transaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'source': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TransactionUpdateInput,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Transaction record.

        Parameters
        ----------
        data
            Transaction record data specifying what to update
        where
            Transaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The updated Transaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transaction = await Transaction.prisma().update(
            where={
                'id': 'gabahhhjf',
            },
            data={
                # data to update the Transaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TransactionWhereUniqueInput,
        data: types.TransactionUpsertInput,
        include: Optional[types.TransactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Transaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created or updated Transaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().upsert(
            where={
                'id': 'cjagadcjg',
            },
            data={
                'create': {
                    'id': 'cjagadcjg',
                    'productId': 'cahhaghecf',
                    'userId': 'bghcbbcidi',
                    'type': enums.TransactionType.ENTREE,
                    'quantity': 926677639,
                },
                'update': {
                    'productId': 'cahhaghecf',
                    'userId': 'bghcbbcidi',
                    'type': enums.TransactionType.ENTREE,
                    'quantity': 926677639,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TransactionUpdateManyMutationInput,
        where: types.TransactionWhereInput,
    ) -> int:
        """Update multiple Transaction records

        Parameters
        ----------
        data
            Transaction data to update the selected Transaction records to
        where
            Filter to select the Transaction records to update

        Returns
        -------
        int
            The total number of Transaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Transaction records
        total = await Transaction.prisma().update_many(
            data={
                'quantity': 1855826649
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TransactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> types.TransactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TransactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> Union[int, types.TransactionCountAggregateOutput]:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TransactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TransactionWhereInput] = None
    ) -> int:
        """Delete multiple Transaction records.

        Parameters
        ----------
        where
            Optional Transaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Transaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Transaction records
        total = await Transaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TransactionScalarFieldKeys'],
        *,
        where: Optional['types.TransactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TransactionAvgAggregateInput'] = None,
        sum: Optional['types.TransactionSumAggregateInput'] = None,
        min: Optional['types.TransactionMinAggregateInput'] = None,
        max: Optional['types.TransactionMaxAggregateInput'] = None,
        having: Optional['types.TransactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TransactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TransactionGroupByOutput']:
        """Group Transaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Transaction fields to group records by
        where
            Transaction filter to select records
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TransactionGroupByOutput]
            A list of dictionaries representing the Transaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Transaction records by productId values
        # and count how many records are in each group
        results = await Transaction.prisma().group_by(
            ['productId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class StockAdjustmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.StockAdjustment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await StockAdjustment.prisma().query_raw(
            'SELECT * FROM StockAdjustment WHERE id = $1',
            'bgbbaajbic',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.StockAdjustment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await StockAdjustment.prisma().query_first(
            'SELECT * FROM StockAdjustment WHERE productId = $1',
            'eegghdhjb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.StockAdjustmentCreateInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new StockAdjustment record.

        Parameters
        ----------
        data
            StockAdjustment record data
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The created StockAdjustment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a StockAdjustment record from just the required fields
        stockadjustment = await StockAdjustment.prisma().create(
            data={
                # data to create a StockAdjustment record
                'productId': 'daafgidjg',
                'quantity': 632626069,
                'type': enums.TransactionType.ENTREE,
                'reason': 'bhceabbgja',
                'requestedById': 'ehabfhegh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.StockAdjustmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple StockAdjustment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of StockAdjustment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await StockAdjustment.prisma().create_many(
            data=[
                {
                    # data to create a StockAdjustment record
                    'productId': 'bcajcajjbc',
                    'quantity': 1536744465,
                    'type': enums.TransactionType.ENTREE,
                    'reason': 'ececbijji',
                    'requestedById': 'cbcfgdcdhf',
                },
                {
                    # data to create a StockAdjustment record
                    'productId': 'fdgjfbhia',
                    'quantity': 924723277,
                    'type': enums.TransactionType.ENTREE,
                    'reason': 'bgcbjdhjcc',
                    'requestedById': 'bieiidcabj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.StockAdjustmentWhereUniqueInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single StockAdjustment record.

        Parameters
        ----------
        where
            StockAdjustment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The deleted StockAdjustment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().delete(
            where={
                'id': 'bjcbfcieaa',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.StockAdjustmentWhereUniqueInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique StockAdjustment record.

        Parameters
        ----------
        where
            StockAdjustment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The found StockAdjustment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().find_unique(
            where={
                'id': 'cbaaechiej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.StockAdjustmentWhereUniqueInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique StockAdjustment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            StockAdjustment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The found StockAdjustment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().find_unique_or_raise(
            where={
                'id': 'iejbeaaeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
        include: Optional[types.StockAdjustmentInclude] = None,
        order: Optional[Union[types.StockAdjustmentOrderByInput, List[types.StockAdjustmentOrderByInput]]] = None,
        distinct: Optional[List[types.StockAdjustmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple StockAdjustment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of StockAdjustment records returned
        skip
            Ignore the first N results
        where
            StockAdjustment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockAdjustment model
        order
            Order the returned StockAdjustment records by any field
        distinct
            Filter StockAdjustment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.StockAdjustment]
            The list of all StockAdjustment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 StockAdjustment records
        stockadjustments = await StockAdjustment.prisma().find_many(take=10)

        # find the first 5 StockAdjustment records ordered by the quantity field
        stockadjustments = await StockAdjustment.prisma().find_many(
            take=5,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
        include: Optional[types.StockAdjustmentInclude] = None,
        order: Optional[Union[types.StockAdjustmentOrderByInput, List[types.StockAdjustmentOrderByInput]]] = None,
        distinct: Optional[List[types.StockAdjustmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single StockAdjustment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StockAdjustment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockAdjustment model
        order
            Order the returned StockAdjustment records by any field
        distinct
            Filter StockAdjustment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StockAdjustment
            The first StockAdjustment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StockAdjustment record ordered by the type field
        stockadjustment = await StockAdjustment.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
        include: Optional[types.StockAdjustmentInclude] = None,
        order: Optional[Union[types.StockAdjustmentOrderByInput, List[types.StockAdjustmentOrderByInput]]] = None,
        distinct: Optional[List[types.StockAdjustmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single StockAdjustment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StockAdjustment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockAdjustment model
        order
            Order the returned StockAdjustment records by any field
        distinct
            Filter StockAdjustment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StockAdjustment
            The first StockAdjustment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StockAdjustment record ordered by the reason field
        stockadjustment = await StockAdjustment.prisma().find_first_or_raise(
            skip=1,
            order={
                'reason': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.StockAdjustmentUpdateInput,
        where: types.StockAdjustmentWhereUniqueInput,
        include: Optional[types.StockAdjustmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single StockAdjustment record.

        Parameters
        ----------
        data
            StockAdjustment record data specifying what to update
        where
            StockAdjustment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The updated StockAdjustment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().update(
            where={
                'id': 'jcibfcbhf',
            },
            data={
                # data to update the StockAdjustment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.StockAdjustmentWhereUniqueInput,
        data: types.StockAdjustmentUpsertInput,
        include: Optional[types.StockAdjustmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            StockAdjustment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned StockAdjustment model

        Returns
        -------
        prisma.models.StockAdjustment
            The created or updated StockAdjustment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockadjustment = await StockAdjustment.prisma().upsert(
            where={
                'id': 'chdadcaga',
            },
            data={
                'create': {
                    'id': 'chdadcaga',
                    'productId': 'fdgjfbhia',
                    'quantity': 924723277,
                    'type': enums.TransactionType.ENTREE,
                    'reason': 'bgcbjdhjcc',
                    'requestedById': 'bieiidcabj',
                },
                'update': {
                    'productId': 'fdgjfbhia',
                    'quantity': 924723277,
                    'type': enums.TransactionType.ENTREE,
                    'reason': 'bgcbjdhjcc',
                    'requestedById': 'bieiidcabj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.StockAdjustmentUpdateManyMutationInput,
        where: types.StockAdjustmentWhereInput,
    ) -> int:
        """Update multiple StockAdjustment records

        Parameters
        ----------
        data
            StockAdjustment data to update the selected StockAdjustment records to
        where
            Filter to select the StockAdjustment records to update

        Returns
        -------
        int
            The total number of StockAdjustment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all StockAdjustment records
        total = await StockAdjustment.prisma().update_many(
            data={
                'requestedById': 'jicieifbh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of StockAdjustment records present in the database

        Parameters
        ----------
        select
            Select the StockAdjustment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StockAdjustment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StockAdjustmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StockAdjustment.prisma().count()

        # results: prisma.types.StockAdjustmentCountAggregateOutput
        results = await StockAdjustment.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.StockAdjustmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
    ) -> types.StockAdjustmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.StockAdjustmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockAdjustmentWhereInput] = None,
        cursor: Optional[types.StockAdjustmentWhereUniqueInput] = None,
    ) -> Union[int, types.StockAdjustmentCountAggregateOutput]:
        """Count the number of StockAdjustment records present in the database

        Parameters
        ----------
        select
            Select the StockAdjustment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StockAdjustment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StockAdjustmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StockAdjustment.prisma().count()

        # results: prisma.types.StockAdjustmentCountAggregateOutput
        results = await StockAdjustment.prisma().count(
            select={
                '_all': True,
                'approvedById': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.StockAdjustmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.StockAdjustmentWhereInput] = None
    ) -> int:
        """Delete multiple StockAdjustment records.

        Parameters
        ----------
        where
            Optional StockAdjustment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of StockAdjustment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all StockAdjustment records
        total = await StockAdjustment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.StockAdjustmentScalarFieldKeys'],
        *,
        where: Optional['types.StockAdjustmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.StockAdjustmentAvgAggregateInput'] = None,
        sum: Optional['types.StockAdjustmentSumAggregateInput'] = None,
        min: Optional['types.StockAdjustmentMinAggregateInput'] = None,
        max: Optional['types.StockAdjustmentMaxAggregateInput'] = None,
        having: Optional['types.StockAdjustmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.StockAdjustmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.StockAdjustmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.StockAdjustmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.StockAdjustmentGroupByOutput']:
        """Group StockAdjustment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar StockAdjustment fields to group records by
        where
            StockAdjustment filter to select records
        take
            Limit the maximum number of StockAdjustment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.StockAdjustmentGroupByOutput]
            A list of dictionaries representing the StockAdjustment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group StockAdjustment records by approvedAt values
        # and count how many records are in each group
        results = await StockAdjustment.prisma().group_by(
            ['approvedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class StockReceiptActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.StockReceipt]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await StockReceipt.prisma().query_raw(
            'SELECT * FROM StockReceipt WHERE id = $1',
            'fbahdheji',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.StockReceipt
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await StockReceipt.prisma().query_first(
            'SELECT * FROM StockReceipt WHERE productId = $1',
            'cbbheiicgh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.StockReceiptCreateInput,
        include: Optional[types.StockReceiptInclude] = None
    ) -> _PrismaModelT:
        """Create a new StockReceipt record.

        Parameters
        ----------
        data
            StockReceipt record data
        include
            Specifies which relations should be loaded on the returned StockReceipt model

        Returns
        -------
        prisma.models.StockReceipt
            The created StockReceipt record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a StockReceipt record from just the required fields
        stockreceipt = await StockReceipt.prisma().create(
            data={
                # data to create a StockReceipt record
                'productId': 'beabjeejdg',
                'quantity': 1297607553,
                'requestedById': 'fbjeiiffa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.StockReceiptCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple StockReceipt records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of StockReceipt record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await StockReceipt.prisma().create_many(
            data=[
                {
                    # data to create a StockReceipt record
                    'productId': 'jhgidcgbf',
                    'quantity': 1696425492,
                    'requestedById': 'bgjcgchib',
                },
                {
                    # data to create a StockReceipt record
                    'productId': 'bacdaibgfa',
                    'quantity': 327681027,
                    'requestedById': 'fchheijjc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.StockReceiptWhereUniqueInput,
        include: Optional[types.StockReceiptInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single StockReceipt record.

        Parameters
        ----------
        where
            StockReceipt filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned StockReceipt model

        Returns
        -------
        prisma.models.StockReceipt
            The deleted StockReceipt record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockreceipt = await StockReceipt.prisma().delete(
            where={
                'id': 'cacjdfhejh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.StockReceiptWhereUniqueInput,
        include: Optional[types.StockReceiptInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique StockReceipt record.

        Parameters
        ----------
        where
            StockReceipt filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StockReceipt model

        Returns
        -------
        prisma.models.StockReceipt
            The found StockReceipt record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockreceipt = await StockReceipt.prisma().find_unique(
            where={
                'id': 'bdbifjhbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.StockReceiptWhereUniqueInput,
        include: Optional[types.StockReceiptInclude] = None
    ) -> _PrismaModelT:
        """Find a unique StockReceipt record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            StockReceipt filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StockReceipt model

        Returns
        -------
        prisma.models.StockReceipt
            The found StockReceipt record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockreceipt = await StockReceipt.prisma().find_unique_or_raise(
            where={
                'id': 'cbccbbcdfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockReceiptWhereInput] = None,
        cursor: Optional[types.StockReceiptWhereUniqueInput] = None,
        include: Optional[types.StockReceiptInclude] = None,
        order: Optional[Union[types.StockReceiptOrderByInput, List[types.StockReceiptOrderByInput]]] = None,
        distinct: Optional[List[types.StockReceiptScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple StockReceipt records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of StockReceipt records returned
        skip
            Ignore the first N results
        where
            StockReceipt filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockReceipt model
        order
            Order the returned StockReceipt records by any field
        distinct
            Filter StockReceipt records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.StockReceipt]
            The list of all StockReceipt records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 StockReceipt records
        stockreceipts = await StockReceipt.prisma().find_many(take=10)

        # find the first 5 StockReceipt records ordered by the quantity field
        stockreceipts = await StockReceipt.prisma().find_many(
            take=5,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StockReceiptWhereInput] = None,
        cursor: Optional[types.StockReceiptWhereUniqueInput] = None,
        include: Optional[types.StockReceiptInclude] = None,
        order: Optional[Union[types.StockReceiptOrderByInput, List[types.StockReceiptOrderByInput]]] = None,
        distinct: Optional[List[types.StockReceiptScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single StockReceipt record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StockReceipt filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockReceipt model
        order
            Order the returned StockReceipt records by any field
        distinct
            Filter StockReceipt records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StockReceipt
            The first StockReceipt record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StockReceipt record ordered by the supplierName field
        stockreceipt = await StockReceipt.prisma().find_first(
            skip=1,
            order={
                'supplierName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StockReceiptWhereInput] = None,
        cursor: Optional[types.StockReceiptWhereUniqueInput] = None,
        include: Optional[types.StockReceiptInclude] = None,
        order: Optional[Union[types.StockReceiptOrderByInput, List[types.StockReceiptOrderByInput]]] = None,
        distinct: Optional[List[types.StockReceiptScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single StockReceipt record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StockReceipt filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StockReceipt model
        order
            Order the returned StockReceipt records by any field
        distinct
            Filter StockReceipt records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StockReceipt
            The first StockReceipt record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StockReceipt record ordered by the batchNumber field
        stockreceipt = await StockReceipt.prisma().find_first_or_raise(
            skip=1,
            order={
                'batchNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.StockReceiptUpdateInput,
        where: types.StockReceiptWhereUniqueInput,
        include: Optional[types.StockReceiptInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single StockReceipt record.

        Parameters
        ----------
        data
            StockReceipt record data specifying what to update
        where
            StockReceipt filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned StockReceipt model

        Returns
        -------
        prisma.models.StockReceipt
            The updated StockReceipt record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        stockreceipt = await StockReceipt.prisma().update(
            where={
                'id': 'bacejedaca',
            },
            data={
                # data to update the StockReceipt record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.StockReceiptWhereUniqueInput,
        data: types.StockReceiptUpsertInput,
        include: Optional[types.StockReceiptInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            StockReceipt filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned StockReceipt model

        Returns
        -------
        prisma.models.StockReceipt
            The created or updated StockReceipt record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        stockreceipt = await StockReceipt.prisma().upsert(
            where={
                'id': 'bhbhdahfaj',
            },
            data={
                'create': {
                    'id': 'bhbhdahfaj',
                    'productId': 'bacdaibgfa',
                    'quantity': 327681027,
                    'requestedById': 'fchheijjc',
                },
                'update': {
                    'productId': 'bacdaibgfa',
                    'quantity': 327681027,
                    'requestedById': 'fchheijjc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.StockReceiptUpdateManyMutationInput,
        where: types.StockReceiptWhereInput,
    ) -> int:
        """Update multiple StockReceipt records

        Parameters
        ----------
        data
            StockReceipt data to update the selected StockReceipt records to
        where
            Filter to select the StockReceipt records to update

        Returns
        -------
        int
            The total number of StockReceipt records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all StockReceipt records
        total = await StockReceipt.prisma().update_many(
            data={
                'requestedById': 'bfjibceaec'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockReceiptWhereInput] = None,
        cursor: Optional[types.StockReceiptWhereUniqueInput] = None,
    ) -> int:
        """Count the number of StockReceipt records present in the database

        Parameters
        ----------
        select
            Select the StockReceipt fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StockReceipt filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StockReceiptCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StockReceipt.prisma().count()

        # results: prisma.types.StockReceiptCountAggregateOutput
        results = await StockReceipt.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.StockReceiptCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockReceiptWhereInput] = None,
        cursor: Optional[types.StockReceiptWhereUniqueInput] = None,
    ) -> types.StockReceiptCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.StockReceiptCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StockReceiptWhereInput] = None,
        cursor: Optional[types.StockReceiptWhereUniqueInput] = None,
    ) -> Union[int, types.StockReceiptCountAggregateOutput]:
        """Count the number of StockReceipt records present in the database

        Parameters
        ----------
        select
            Select the StockReceipt fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StockReceipt filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StockReceiptCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StockReceipt.prisma().count()

        # results: prisma.types.StockReceiptCountAggregateOutput
        results = await StockReceipt.prisma().count(
            select={
                '_all': True,
                'approvedById': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.StockReceiptCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.StockReceiptWhereInput] = None
    ) -> int:
        """Delete multiple StockReceipt records.

        Parameters
        ----------
        where
            Optional StockReceipt filter to find the records to be deleted

        Returns
        -------
        int
            The total number of StockReceipt records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all StockReceipt records
        total = await StockReceipt.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.StockReceiptScalarFieldKeys'],
        *,
        where: Optional['types.StockReceiptWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.StockReceiptAvgAggregateInput'] = None,
        sum: Optional['types.StockReceiptSumAggregateInput'] = None,
        min: Optional['types.StockReceiptMinAggregateInput'] = None,
        max: Optional['types.StockReceiptMaxAggregateInput'] = None,
        having: Optional['types.StockReceiptScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.StockReceiptCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.StockReceiptScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.StockReceiptScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.StockReceiptGroupByOutput']:
        """Group StockReceipt records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar StockReceipt fields to group records by
        where
            StockReceipt filter to select records
        take
            Limit the maximum number of StockReceipt records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.StockReceiptGroupByOutput]
            A list of dictionaries representing the StockReceipt record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group StockReceipt records by approvedAt values
        # and count how many records are in each group
        results = await StockReceipt.prisma().group_by(
            ['approvedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PurchaseOrderActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PurchaseOrder]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PurchaseOrder.prisma().query_raw(
            'SELECT * FROM PurchaseOrder WHERE id = $1',
            'ibhgcdbgd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PurchaseOrder
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PurchaseOrder.prisma().query_first(
            'SELECT * FROM PurchaseOrder WHERE orderNumber = $1',
            'badaffhddg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PurchaseOrderCreateInput,
        include: Optional[types.PurchaseOrderInclude] = None
    ) -> _PrismaModelT:
        """Create a new PurchaseOrder record.

        Parameters
        ----------
        data
            PurchaseOrder record data
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model

        Returns
        -------
        prisma.models.PurchaseOrder
            The created PurchaseOrder record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PurchaseOrder record from just the required fields
        purchaseorder = await PurchaseOrder.prisma().create(
            data={
                # data to create a PurchaseOrder record
                'requestedById': 'bbdbfcfihd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PurchaseOrderCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PurchaseOrder records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PurchaseOrder record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PurchaseOrder.prisma().create_many(
            data=[
                {
                    # data to create a PurchaseOrder record
                    'requestedById': 'cbagggbji',
                },
                {
                    # data to create a PurchaseOrder record
                    'requestedById': 'bchgafhjed',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PurchaseOrderWhereUniqueInput,
        include: Optional[types.PurchaseOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PurchaseOrder record.

        Parameters
        ----------
        where
            PurchaseOrder filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model

        Returns
        -------
        prisma.models.PurchaseOrder
            The deleted PurchaseOrder record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        purchaseorder = await PurchaseOrder.prisma().delete(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PurchaseOrderWhereUniqueInput,
        include: Optional[types.PurchaseOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PurchaseOrder record.

        Parameters
        ----------
        where
            PurchaseOrder filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model

        Returns
        -------
        prisma.models.PurchaseOrder
            The found PurchaseOrder record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        purchaseorder = await PurchaseOrder.prisma().find_unique(
            where={
                'id': 'dahihgbeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PurchaseOrderWhereUniqueInput,
        include: Optional[types.PurchaseOrderInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PurchaseOrder record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PurchaseOrder filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model

        Returns
        -------
        prisma.models.PurchaseOrder
            The found PurchaseOrder record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        purchaseorder = await PurchaseOrder.prisma().find_unique_or_raise(
            where={
                'id': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderWhereInput] = None,
        cursor: Optional[types.PurchaseOrderWhereUniqueInput] = None,
        include: Optional[types.PurchaseOrderInclude] = None,
        order: Optional[Union[types.PurchaseOrderOrderByInput, List[types.PurchaseOrderOrderByInput]]] = None,
        distinct: Optional[List[types.PurchaseOrderScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PurchaseOrder records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PurchaseOrder records returned
        skip
            Ignore the first N results
        where
            PurchaseOrder filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model
        order
            Order the returned PurchaseOrder records by any field
        distinct
            Filter PurchaseOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PurchaseOrder]
            The list of all PurchaseOrder records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PurchaseOrder records
        purchaseorders = await PurchaseOrder.prisma().find_many(take=10)

        # find the first 5 PurchaseOrder records ordered by the status field
        purchaseorders = await PurchaseOrder.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderWhereInput] = None,
        cursor: Optional[types.PurchaseOrderWhereUniqueInput] = None,
        include: Optional[types.PurchaseOrderInclude] = None,
        order: Optional[Union[types.PurchaseOrderOrderByInput, List[types.PurchaseOrderOrderByInput]]] = None,
        distinct: Optional[List[types.PurchaseOrderScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PurchaseOrder record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PurchaseOrder filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model
        order
            Order the returned PurchaseOrder records by any field
        distinct
            Filter PurchaseOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PurchaseOrder
            The first PurchaseOrder record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PurchaseOrder record ordered by the requestedById field
        purchaseorder = await PurchaseOrder.prisma().find_first(
            skip=1,
            order={
                'requestedById': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderWhereInput] = None,
        cursor: Optional[types.PurchaseOrderWhereUniqueInput] = None,
        include: Optional[types.PurchaseOrderInclude] = None,
        order: Optional[Union[types.PurchaseOrderOrderByInput, List[types.PurchaseOrderOrderByInput]]] = None,
        distinct: Optional[List[types.PurchaseOrderScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PurchaseOrder record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PurchaseOrder filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model
        order
            Order the returned PurchaseOrder records by any field
        distinct
            Filter PurchaseOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PurchaseOrder
            The first PurchaseOrder record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PurchaseOrder record ordered by the approvedById field
        purchaseorder = await PurchaseOrder.prisma().find_first_or_raise(
            skip=1,
            order={
                'approvedById': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PurchaseOrderUpdateInput,
        where: types.PurchaseOrderWhereUniqueInput,
        include: Optional[types.PurchaseOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PurchaseOrder record.

        Parameters
        ----------
        data
            PurchaseOrder record data specifying what to update
        where
            PurchaseOrder filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model

        Returns
        -------
        prisma.models.PurchaseOrder
            The updated PurchaseOrder record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        purchaseorder = await PurchaseOrder.prisma().update(
            where={
                'id': 'bfcgifeged',
            },
            data={
                # data to update the PurchaseOrder record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PurchaseOrderWhereUniqueInput,
        data: types.PurchaseOrderUpsertInput,
        include: Optional[types.PurchaseOrderInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PurchaseOrder filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PurchaseOrder model

        Returns
        -------
        prisma.models.PurchaseOrder
            The created or updated PurchaseOrder record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        purchaseorder = await PurchaseOrder.prisma().upsert(
            where={
                'id': 'jfiahhbae',
            },
            data={
                'create': {
                    'id': 'jfiahhbae',
                    'requestedById': 'bchgafhjed',
                },
                'update': {
                    'requestedById': 'bchgafhjed',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PurchaseOrderUpdateManyMutationInput,
        where: types.PurchaseOrderWhereInput,
    ) -> int:
        """Update multiple PurchaseOrder records

        Parameters
        ----------
        data
            PurchaseOrder data to update the selected PurchaseOrder records to
        where
            Filter to select the PurchaseOrder records to update

        Returns
        -------
        int
            The total number of PurchaseOrder records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PurchaseOrder records
        total = await PurchaseOrder.prisma().update_many(
            data={
                'supplierName': 'bfbdafajcb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderWhereInput] = None,
        cursor: Optional[types.PurchaseOrderWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PurchaseOrder records present in the database

        Parameters
        ----------
        select
            Select the PurchaseOrder fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PurchaseOrder filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PurchaseOrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PurchaseOrder.prisma().count()

        # results: prisma.types.PurchaseOrderCountAggregateOutput
        results = await PurchaseOrder.prisma().count(
            select={
                '_all': True,
                'totalAmount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PurchaseOrderCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderWhereInput] = None,
        cursor: Optional[types.PurchaseOrderWhereUniqueInput] = None,
    ) -> types.PurchaseOrderCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PurchaseOrderCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderWhereInput] = None,
        cursor: Optional[types.PurchaseOrderWhereUniqueInput] = None,
    ) -> Union[int, types.PurchaseOrderCountAggregateOutput]:
        """Count the number of PurchaseOrder records present in the database

        Parameters
        ----------
        select
            Select the PurchaseOrder fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PurchaseOrder filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PurchaseOrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PurchaseOrder.prisma().count()

        # results: prisma.types.PurchaseOrderCountAggregateOutput
        results = await PurchaseOrder.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PurchaseOrderCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PurchaseOrderWhereInput] = None
    ) -> int:
        """Delete multiple PurchaseOrder records.

        Parameters
        ----------
        where
            Optional PurchaseOrder filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PurchaseOrder records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PurchaseOrder records
        total = await PurchaseOrder.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PurchaseOrderScalarFieldKeys'],
        *,
        where: Optional['types.PurchaseOrderWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PurchaseOrderAvgAggregateInput'] = None,
        sum: Optional['types.PurchaseOrderSumAggregateInput'] = None,
        min: Optional['types.PurchaseOrderMinAggregateInput'] = None,
        max: Optional['types.PurchaseOrderMaxAggregateInput'] = None,
        having: Optional['types.PurchaseOrderScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PurchaseOrderCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PurchaseOrderScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PurchaseOrderScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PurchaseOrderGroupByOutput']:
        """Group PurchaseOrder records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PurchaseOrder fields to group records by
        where
            PurchaseOrder filter to select records
        take
            Limit the maximum number of PurchaseOrder records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PurchaseOrderGroupByOutput]
            A list of dictionaries representing the PurchaseOrder record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PurchaseOrder records by updatedAt values
        # and count how many records are in each group
        results = await PurchaseOrder.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PurchaseOrderItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PurchaseOrderItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PurchaseOrderItem.prisma().query_raw(
            'SELECT * FROM PurchaseOrderItem WHERE id = $1',
            'caeghehde',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PurchaseOrderItem.prisma().query_first(
            'SELECT * FROM PurchaseOrderItem WHERE purchaseOrderId = $1',
            'caghgfbggd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PurchaseOrderItemCreateInput,
        include: Optional[types.PurchaseOrderItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new PurchaseOrderItem record.

        Parameters
        ----------
        data
            PurchaseOrderItem record data
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The created PurchaseOrderItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PurchaseOrderItem record from just the required fields
        purchaseorderitem = await PurchaseOrderItem.prisma().create(
            data={
                # data to create a PurchaseOrderItem record
                'purchaseOrderId': 'bbidjbbjaa',
                'productId': 'bfijhaejdd',
                'quantity': 1243475898,
                'unitPrice': 1369828971.167859,
                'totalPrice': 403521121.64876,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PurchaseOrderItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PurchaseOrderItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PurchaseOrderItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PurchaseOrderItem.prisma().create_many(
            data=[
                {
                    # data to create a PurchaseOrderItem record
                    'purchaseOrderId': 'gahdcdhbj',
                    'productId': 'begiijahea',
                    'quantity': 629039005,
                    'unitPrice': 1214168082.89861,
                    'totalPrice': 658378208.95462,
                },
                {
                    # data to create a PurchaseOrderItem record
                    'purchaseOrderId': 'bcbeiajjfa',
                    'productId': 'baehicaajf',
                    'quantity': 1302734860,
                    'unitPrice': 893052245.28008,
                    'totalPrice': 549668955.7679,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PurchaseOrderItemWhereUniqueInput,
        include: Optional[types.PurchaseOrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PurchaseOrderItem record.

        Parameters
        ----------
        where
            PurchaseOrderItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The deleted PurchaseOrderItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        purchaseorderitem = await PurchaseOrderItem.prisma().delete(
            where={
                'id': 'cajicjjdef',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PurchaseOrderItemWhereUniqueInput,
        include: Optional[types.PurchaseOrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PurchaseOrderItem record.

        Parameters
        ----------
        where
            PurchaseOrderItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The found PurchaseOrderItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        purchaseorderitem = await PurchaseOrderItem.prisma().find_unique(
            where={
                'id': 'cefjaadec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PurchaseOrderItemWhereUniqueInput,
        include: Optional[types.PurchaseOrderItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PurchaseOrderItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PurchaseOrderItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The found PurchaseOrderItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        purchaseorderitem = await PurchaseOrderItem.prisma().find_unique_or_raise(
            where={
                'id': 'ibbigdigd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderItemWhereInput] = None,
        cursor: Optional[types.PurchaseOrderItemWhereUniqueInput] = None,
        include: Optional[types.PurchaseOrderItemInclude] = None,
        order: Optional[Union[types.PurchaseOrderItemOrderByInput, List[types.PurchaseOrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.PurchaseOrderItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PurchaseOrderItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PurchaseOrderItem records returned
        skip
            Ignore the first N results
        where
            PurchaseOrderItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model
        order
            Order the returned PurchaseOrderItem records by any field
        distinct
            Filter PurchaseOrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PurchaseOrderItem]
            The list of all PurchaseOrderItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PurchaseOrderItem records
        purchaseorderitems = await PurchaseOrderItem.prisma().find_many(take=10)

        # find the first 5 PurchaseOrderItem records ordered by the productId field
        purchaseorderitems = await PurchaseOrderItem.prisma().find_many(
            take=5,
            order={
                'productId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderItemWhereInput] = None,
        cursor: Optional[types.PurchaseOrderItemWhereUniqueInput] = None,
        include: Optional[types.PurchaseOrderItemInclude] = None,
        order: Optional[Union[types.PurchaseOrderItemOrderByInput, List[types.PurchaseOrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.PurchaseOrderItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PurchaseOrderItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PurchaseOrderItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model
        order
            Order the returned PurchaseOrderItem records by any field
        distinct
            Filter PurchaseOrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The first PurchaseOrderItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PurchaseOrderItem record ordered by the quantity field
        purchaseorderitem = await PurchaseOrderItem.prisma().find_first(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderItemWhereInput] = None,
        cursor: Optional[types.PurchaseOrderItemWhereUniqueInput] = None,
        include: Optional[types.PurchaseOrderItemInclude] = None,
        order: Optional[Union[types.PurchaseOrderItemOrderByInput, List[types.PurchaseOrderItemOrderByInput]]] = None,
        distinct: Optional[List[types.PurchaseOrderItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PurchaseOrderItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PurchaseOrderItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model
        order
            Order the returned PurchaseOrderItem records by any field
        distinct
            Filter PurchaseOrderItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The first PurchaseOrderItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PurchaseOrderItem record ordered by the unitPrice field
        purchaseorderitem = await PurchaseOrderItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'unitPrice': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PurchaseOrderItemUpdateInput,
        where: types.PurchaseOrderItemWhereUniqueInput,
        include: Optional[types.PurchaseOrderItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PurchaseOrderItem record.

        Parameters
        ----------
        data
            PurchaseOrderItem record data specifying what to update
        where
            PurchaseOrderItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The updated PurchaseOrderItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        purchaseorderitem = await PurchaseOrderItem.prisma().update(
            where={
                'id': 'bdiiiabbii',
            },
            data={
                # data to update the PurchaseOrderItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PurchaseOrderItemWhereUniqueInput,
        data: types.PurchaseOrderItemUpsertInput,
        include: Optional[types.PurchaseOrderItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PurchaseOrderItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PurchaseOrderItem model

        Returns
        -------
        prisma.models.PurchaseOrderItem
            The created or updated PurchaseOrderItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        purchaseorderitem = await PurchaseOrderItem.prisma().upsert(
            where={
                'id': 'hfcfhhadh',
            },
            data={
                'create': {
                    'id': 'hfcfhhadh',
                    'purchaseOrderId': 'bcbeiajjfa',
                    'productId': 'baehicaajf',
                    'quantity': 1302734860,
                    'unitPrice': 893052245.28008,
                    'totalPrice': 549668955.7679,
                },
                'update': {
                    'purchaseOrderId': 'bcbeiajjfa',
                    'productId': 'baehicaajf',
                    'quantity': 1302734860,
                    'unitPrice': 893052245.28008,
                    'totalPrice': 549668955.7679,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PurchaseOrderItemUpdateManyMutationInput,
        where: types.PurchaseOrderItemWhereInput,
    ) -> int:
        """Update multiple PurchaseOrderItem records

        Parameters
        ----------
        data
            PurchaseOrderItem data to update the selected PurchaseOrderItem records to
        where
            Filter to select the PurchaseOrderItem records to update

        Returns
        -------
        int
            The total number of PurchaseOrderItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PurchaseOrderItem records
        total = await PurchaseOrderItem.prisma().update_many(
            data={
                'totalPrice': 1187663298.76968
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderItemWhereInput] = None,
        cursor: Optional[types.PurchaseOrderItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PurchaseOrderItem records present in the database

        Parameters
        ----------
        select
            Select the PurchaseOrderItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PurchaseOrderItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PurchaseOrderItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PurchaseOrderItem.prisma().count()

        # results: prisma.types.PurchaseOrderItemCountAggregateOutput
        results = await PurchaseOrderItem.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PurchaseOrderItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderItemWhereInput] = None,
        cursor: Optional[types.PurchaseOrderItemWhereUniqueInput] = None,
    ) -> types.PurchaseOrderItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PurchaseOrderItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PurchaseOrderItemWhereInput] = None,
        cursor: Optional[types.PurchaseOrderItemWhereUniqueInput] = None,
    ) -> Union[int, types.PurchaseOrderItemCountAggregateOutput]:
        """Count the number of PurchaseOrderItem records present in the database

        Parameters
        ----------
        select
            Select the PurchaseOrderItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PurchaseOrderItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PurchaseOrderItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PurchaseOrderItem.prisma().count()

        # results: prisma.types.PurchaseOrderItemCountAggregateOutput
        results = await PurchaseOrderItem.prisma().count(
            select={
                '_all': True,
                'purchaseOrderId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PurchaseOrderItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PurchaseOrderItemWhereInput] = None
    ) -> int:
        """Delete multiple PurchaseOrderItem records.

        Parameters
        ----------
        where
            Optional PurchaseOrderItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PurchaseOrderItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PurchaseOrderItem records
        total = await PurchaseOrderItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PurchaseOrderItemScalarFieldKeys'],
        *,
        where: Optional['types.PurchaseOrderItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PurchaseOrderItemAvgAggregateInput'] = None,
        sum: Optional['types.PurchaseOrderItemSumAggregateInput'] = None,
        min: Optional['types.PurchaseOrderItemMinAggregateInput'] = None,
        max: Optional['types.PurchaseOrderItemMaxAggregateInput'] = None,
        having: Optional['types.PurchaseOrderItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PurchaseOrderItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PurchaseOrderItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PurchaseOrderItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PurchaseOrderItemGroupByOutput']:
        """Group PurchaseOrderItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PurchaseOrderItem fields to group records by
        where
            PurchaseOrderItem filter to select records
        take
            Limit the maximum number of PurchaseOrderItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PurchaseOrderItemGroupByOutput]
            A list of dictionaries representing the PurchaseOrderItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PurchaseOrderItem records by productId values
        # and count how many records are in each group
        results = await PurchaseOrderItem.prisma().group_by(
            ['productId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CounterActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Counter]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Counter.prisma().query_raw(
            'SELECT * FROM Counter WHERE id = $1',
            'bcbecjfice',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Counter
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Counter.prisma().query_first(
            'SELECT * FROM Counter WHERE type = $1',
            'bacbebhjjd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CounterCreateInput,
        include: Optional[types.CounterInclude] = None
    ) -> _PrismaModelT:
        """Create a new Counter record.

        Parameters
        ----------
        data
            Counter record data
        include
            Specifies which relations should be loaded on the returned Counter model

        Returns
        -------
        prisma.models.Counter
            The created Counter record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Counter record from just the required fields
        counter = await Counter.prisma().create(
            data={
                # data to create a Counter record
                'type': 'dfbfaddhe',
                'year': 1321184815,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CounterCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Counter records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Counter record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Counter.prisma().create_many(
            data=[
                {
                    # data to create a Counter record
                    'type': 'dgjhdcggi',
                    'year': 1191235013,
                },
                {
                    # data to create a Counter record
                    'type': 'gchfgbcec',
                    'year': 1872952907,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CounterWhereUniqueInput,
        include: Optional[types.CounterInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Counter record.

        Parameters
        ----------
        where
            Counter filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Counter model

        Returns
        -------
        prisma.models.Counter
            The deleted Counter record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        counter = await Counter.prisma().delete(
            where={
                'id': 'bhjdcicaii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CounterWhereUniqueInput,
        include: Optional[types.CounterInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Counter record.

        Parameters
        ----------
        where
            Counter filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Counter model

        Returns
        -------
        prisma.models.Counter
            The found Counter record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        counter = await Counter.prisma().find_unique(
            where={
                'id': 'bibedjhcej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CounterWhereUniqueInput,
        include: Optional[types.CounterInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Counter record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Counter filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Counter model

        Returns
        -------
        prisma.models.Counter
            The found Counter record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        counter = await Counter.prisma().find_unique_or_raise(
            where={
                'id': 'bjcdajabfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CounterWhereInput] = None,
        cursor: Optional[types.CounterWhereUniqueInput] = None,
        include: Optional[types.CounterInclude] = None,
        order: Optional[Union[types.CounterOrderByInput, List[types.CounterOrderByInput]]] = None,
        distinct: Optional[List[types.CounterScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Counter records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Counter records returned
        skip
            Ignore the first N results
        where
            Counter filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Counter model
        order
            Order the returned Counter records by any field
        distinct
            Filter Counter records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Counter]
            The list of all Counter records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Counter records
        counters = await Counter.prisma().find_many(take=10)

        # find the first 5 Counter records ordered by the year field
        counters = await Counter.prisma().find_many(
            take=5,
            order={
                'year': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CounterWhereInput] = None,
        cursor: Optional[types.CounterWhereUniqueInput] = None,
        include: Optional[types.CounterInclude] = None,
        order: Optional[Union[types.CounterOrderByInput, List[types.CounterOrderByInput]]] = None,
        distinct: Optional[List[types.CounterScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Counter record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Counter filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Counter model
        order
            Order the returned Counter records by any field
        distinct
            Filter Counter records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Counter
            The first Counter record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Counter record ordered by the lastNumber field
        counter = await Counter.prisma().find_first(
            skip=1,
            order={
                'lastNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CounterWhereInput] = None,
        cursor: Optional[types.CounterWhereUniqueInput] = None,
        include: Optional[types.CounterInclude] = None,
        order: Optional[Union[types.CounterOrderByInput, List[types.CounterOrderByInput]]] = None,
        distinct: Optional[List[types.CounterScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Counter record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Counter filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Counter model
        order
            Order the returned Counter records by any field
        distinct
            Filter Counter records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Counter
            The first Counter record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Counter record ordered by the id field
        counter = await Counter.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CounterUpdateInput,
        where: types.CounterWhereUniqueInput,
        include: Optional[types.CounterInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Counter record.

        Parameters
        ----------
        data
            Counter record data specifying what to update
        where
            Counter filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Counter model

        Returns
        -------
        prisma.models.Counter
            The updated Counter record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        counter = await Counter.prisma().update(
            where={
                'id': 'bchhceeeff',
            },
            data={
                # data to update the Counter record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CounterWhereUniqueInput,
        data: types.CounterUpsertInput,
        include: Optional[types.CounterInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Counter filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Counter model

        Returns
        -------
        prisma.models.Counter
            The created or updated Counter record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        counter = await Counter.prisma().upsert(
            where={
                'id': 'bbgaifhdaa',
            },
            data={
                'create': {
                    'id': 'bbgaifhdaa',
                    'type': 'gchfgbcec',
                    'year': 1872952907,
                },
                'update': {
                    'type': 'gchfgbcec',
                    'year': 1872952907,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CounterUpdateManyMutationInput,
        where: types.CounterWhereInput,
    ) -> int:
        """Update multiple Counter records

        Parameters
        ----------
        data
            Counter data to update the selected Counter records to
        where
            Filter to select the Counter records to update

        Returns
        -------
        int
            The total number of Counter records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Counter records
        total = await Counter.prisma().update_many(
            data={
                'type': 'dgbcdaegb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CounterWhereInput] = None,
        cursor: Optional[types.CounterWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Counter records present in the database

        Parameters
        ----------
        select
            Select the Counter fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Counter filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CounterCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Counter.prisma().count()

        # results: prisma.types.CounterCountAggregateOutput
        results = await Counter.prisma().count(
            select={
                '_all': True,
                'year': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CounterCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CounterWhereInput] = None,
        cursor: Optional[types.CounterWhereUniqueInput] = None,
    ) -> types.CounterCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CounterCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CounterWhereInput] = None,
        cursor: Optional[types.CounterWhereUniqueInput] = None,
    ) -> Union[int, types.CounterCountAggregateOutput]:
        """Count the number of Counter records present in the database

        Parameters
        ----------
        select
            Select the Counter fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Counter filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CounterCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Counter.prisma().count()

        # results: prisma.types.CounterCountAggregateOutput
        results = await Counter.prisma().count(
            select={
                '_all': True,
                'lastNumber': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CounterCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CounterWhereInput] = None
    ) -> int:
        """Delete multiple Counter records.

        Parameters
        ----------
        where
            Optional Counter filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Counter records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Counter records
        total = await Counter.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CounterScalarFieldKeys'],
        *,
        where: Optional['types.CounterWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CounterAvgAggregateInput'] = None,
        sum: Optional['types.CounterSumAggregateInput'] = None,
        min: Optional['types.CounterMinAggregateInput'] = None,
        max: Optional['types.CounterMaxAggregateInput'] = None,
        having: Optional['types.CounterScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CounterCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CounterScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CounterScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CounterGroupByOutput']:
        """Group Counter records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Counter fields to group records by
        where
            Counter filter to select records
        take
            Limit the maximum number of Counter records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CounterGroupByOutput]
            A list of dictionaries representing the Counter record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Counter records by id values
        # and count how many records are in each group
        results = await Counter.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InventoryAuditActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.InventoryAudit]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await InventoryAudit.prisma().query_raw(
            'SELECT * FROM InventoryAudit WHERE id = $1',
            'beagfbbjig',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.InventoryAudit
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await InventoryAudit.prisma().query_first(
            'SELECT * FROM InventoryAudit WHERE auditNumber = $1',
            'beicihhijb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InventoryAuditCreateInput,
        include: Optional[types.InventoryAuditInclude] = None
    ) -> _PrismaModelT:
        """Create a new InventoryAudit record.

        Parameters
        ----------
        data
            InventoryAudit record data
        include
            Specifies which relations should be loaded on the returned InventoryAudit model

        Returns
        -------
        prisma.models.InventoryAudit
            The created InventoryAudit record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a InventoryAudit record from just the required fields
        inventoryaudit = await InventoryAudit.prisma().create(
            data={
                # data to create a InventoryAudit record
                'auditNumber': 'fgggcdcjg',
                'createdById': 'ccjbbjigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InventoryAuditCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple InventoryAudit records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of InventoryAudit record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await InventoryAudit.prisma().create_many(
            data=[
                {
                    # data to create a InventoryAudit record
                    'auditNumber': 'bhfaabbaha',
                    'createdById': 'ebajedhhf',
                },
                {
                    # data to create a InventoryAudit record
                    'auditNumber': 'jajacedge',
                    'createdById': 'hffgbabgf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InventoryAuditWhereUniqueInput,
        include: Optional[types.InventoryAuditInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single InventoryAudit record.

        Parameters
        ----------
        where
            InventoryAudit filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryAudit model

        Returns
        -------
        prisma.models.InventoryAudit
            The deleted InventoryAudit record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryaudit = await InventoryAudit.prisma().delete(
            where={
                'id': 'biacbiieja',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InventoryAuditWhereUniqueInput,
        include: Optional[types.InventoryAuditInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique InventoryAudit record.

        Parameters
        ----------
        where
            InventoryAudit filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryAudit model

        Returns
        -------
        prisma.models.InventoryAudit
            The found InventoryAudit record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryaudit = await InventoryAudit.prisma().find_unique(
            where={
                'id': 'cjejbgbff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InventoryAuditWhereUniqueInput,
        include: Optional[types.InventoryAuditInclude] = None
    ) -> _PrismaModelT:
        """Find a unique InventoryAudit record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            InventoryAudit filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryAudit model

        Returns
        -------
        prisma.models.InventoryAudit
            The found InventoryAudit record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryaudit = await InventoryAudit.prisma().find_unique_or_raise(
            where={
                'id': 'fgeahddae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditWhereInput] = None,
        cursor: Optional[types.InventoryAuditWhereUniqueInput] = None,
        include: Optional[types.InventoryAuditInclude] = None,
        order: Optional[Union[types.InventoryAuditOrderByInput, List[types.InventoryAuditOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryAuditScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple InventoryAudit records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of InventoryAudit records returned
        skip
            Ignore the first N results
        where
            InventoryAudit filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryAudit model
        order
            Order the returned InventoryAudit records by any field
        distinct
            Filter InventoryAudit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.InventoryAudit]
            The list of all InventoryAudit records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 InventoryAudit records
        inventoryaudits = await InventoryAudit.prisma().find_many(take=10)

        # find the first 5 InventoryAudit records ordered by the status field
        inventoryaudits = await InventoryAudit.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditWhereInput] = None,
        cursor: Optional[types.InventoryAuditWhereUniqueInput] = None,
        include: Optional[types.InventoryAuditInclude] = None,
        order: Optional[Union[types.InventoryAuditOrderByInput, List[types.InventoryAuditOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryAuditScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single InventoryAudit record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryAudit filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryAudit model
        order
            Order the returned InventoryAudit records by any field
        distinct
            Filter InventoryAudit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryAudit
            The first InventoryAudit record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryAudit record ordered by the createdById field
        inventoryaudit = await InventoryAudit.prisma().find_first(
            skip=1,
            order={
                'createdById': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditWhereInput] = None,
        cursor: Optional[types.InventoryAuditWhereUniqueInput] = None,
        include: Optional[types.InventoryAuditInclude] = None,
        order: Optional[Union[types.InventoryAuditOrderByInput, List[types.InventoryAuditOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryAuditScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single InventoryAudit record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryAudit filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryAudit model
        order
            Order the returned InventoryAudit records by any field
        distinct
            Filter InventoryAudit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryAudit
            The first InventoryAudit record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryAudit record ordered by the createdAt field
        inventoryaudit = await InventoryAudit.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InventoryAuditUpdateInput,
        where: types.InventoryAuditWhereUniqueInput,
        include: Optional[types.InventoryAuditInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single InventoryAudit record.

        Parameters
        ----------
        data
            InventoryAudit record data specifying what to update
        where
            InventoryAudit filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned InventoryAudit model

        Returns
        -------
        prisma.models.InventoryAudit
            The updated InventoryAudit record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        inventoryaudit = await InventoryAudit.prisma().update(
            where={
                'id': 'diageigcf',
            },
            data={
                # data to update the InventoryAudit record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InventoryAuditWhereUniqueInput,
        data: types.InventoryAuditUpsertInput,
        include: Optional[types.InventoryAuditInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            InventoryAudit filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned InventoryAudit model

        Returns
        -------
        prisma.models.InventoryAudit
            The created or updated InventoryAudit record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryaudit = await InventoryAudit.prisma().upsert(
            where={
                'id': 'badagbgeha',
            },
            data={
                'create': {
                    'id': 'badagbgeha',
                    'auditNumber': 'jajacedge',
                    'createdById': 'hffgbabgf',
                },
                'update': {
                    'auditNumber': 'jajacedge',
                    'createdById': 'hffgbabgf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InventoryAuditUpdateManyMutationInput,
        where: types.InventoryAuditWhereInput,
    ) -> int:
        """Update multiple InventoryAudit records

        Parameters
        ----------
        data
            InventoryAudit data to update the selected InventoryAudit records to
        where
            Filter to select the InventoryAudit records to update

        Returns
        -------
        int
            The total number of InventoryAudit records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all InventoryAudit records
        total = await InventoryAudit.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditWhereInput] = None,
        cursor: Optional[types.InventoryAuditWhereUniqueInput] = None,
    ) -> int:
        """Count the number of InventoryAudit records present in the database

        Parameters
        ----------
        select
            Select the InventoryAudit fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryAudit filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryAuditCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryAudit.prisma().count()

        # results: prisma.types.InventoryAuditCountAggregateOutput
        results = await InventoryAudit.prisma().count(
            select={
                '_all': True,
                'completedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InventoryAuditCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditWhereInput] = None,
        cursor: Optional[types.InventoryAuditWhereUniqueInput] = None,
    ) -> types.InventoryAuditCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InventoryAuditCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditWhereInput] = None,
        cursor: Optional[types.InventoryAuditWhereUniqueInput] = None,
    ) -> Union[int, types.InventoryAuditCountAggregateOutput]:
        """Count the number of InventoryAudit records present in the database

        Parameters
        ----------
        select
            Select the InventoryAudit fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryAudit filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryAuditCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryAudit.prisma().count()

        # results: prisma.types.InventoryAuditCountAggregateOutput
        results = await InventoryAudit.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InventoryAuditCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InventoryAuditWhereInput] = None
    ) -> int:
        """Delete multiple InventoryAudit records.

        Parameters
        ----------
        where
            Optional InventoryAudit filter to find the records to be deleted

        Returns
        -------
        int
            The total number of InventoryAudit records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all InventoryAudit records
        total = await InventoryAudit.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InventoryAuditScalarFieldKeys'],
        *,
        where: Optional['types.InventoryAuditWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InventoryAuditAvgAggregateInput'] = None,
        sum: Optional['types.InventoryAuditSumAggregateInput'] = None,
        min: Optional['types.InventoryAuditMinAggregateInput'] = None,
        max: Optional['types.InventoryAuditMaxAggregateInput'] = None,
        having: Optional['types.InventoryAuditScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InventoryAuditCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InventoryAuditScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InventoryAuditScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InventoryAuditGroupByOutput']:
        """Group InventoryAudit records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar InventoryAudit fields to group records by
        where
            InventoryAudit filter to select records
        take
            Limit the maximum number of InventoryAudit records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InventoryAuditGroupByOutput]
            A list of dictionaries representing the InventoryAudit record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group InventoryAudit records by auditNumber values
        # and count how many records are in each group
        results = await InventoryAudit.prisma().group_by(
            ['auditNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class InventoryAuditItemActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.InventoryAuditItem]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await InventoryAuditItem.prisma().query_raw(
            'SELECT * FROM InventoryAuditItem WHERE id = $1',
            'ibgebbjch',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.InventoryAuditItem
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await InventoryAuditItem.prisma().query_first(
            'SELECT * FROM InventoryAuditItem WHERE auditId = $1',
            'baieajjiee',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.InventoryAuditItemCreateInput,
        include: Optional[types.InventoryAuditItemInclude] = None
    ) -> _PrismaModelT:
        """Create a new InventoryAuditItem record.

        Parameters
        ----------
        data
            InventoryAuditItem record data
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model

        Returns
        -------
        prisma.models.InventoryAuditItem
            The created InventoryAuditItem record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a InventoryAuditItem record from just the required fields
        inventoryaudititem = await InventoryAuditItem.prisma().create(
            data={
                # data to create a InventoryAuditItem record
                'auditId': 'bahjhaccfd',
                'productId': 'hffhfabhi',
                'systemQuantity': 1128680371,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.InventoryAuditItemCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple InventoryAuditItem records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of InventoryAuditItem record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await InventoryAuditItem.prisma().create_many(
            data=[
                {
                    # data to create a InventoryAuditItem record
                    'auditId': 'cfjagbbae',
                    'productId': 'bbbfhdidef',
                    'systemQuantity': 1303781742,
                },
                {
                    # data to create a InventoryAuditItem record
                    'auditId': 'bfhdjaiejf',
                    'productId': 'bbjfijjadg',
                    'systemQuantity': 739021477,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.InventoryAuditItemWhereUniqueInput,
        include: Optional[types.InventoryAuditItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single InventoryAuditItem record.

        Parameters
        ----------
        where
            InventoryAuditItem filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model

        Returns
        -------
        prisma.models.InventoryAuditItem
            The deleted InventoryAuditItem record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryaudititem = await InventoryAuditItem.prisma().delete(
            where={
                'id': 'bhcccbeaba',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.InventoryAuditItemWhereUniqueInput,
        include: Optional[types.InventoryAuditItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique InventoryAuditItem record.

        Parameters
        ----------
        where
            InventoryAuditItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model

        Returns
        -------
        prisma.models.InventoryAuditItem
            The found InventoryAuditItem record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryaudititem = await InventoryAuditItem.prisma().find_unique(
            where={
                'id': 'bcgjbdgjdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.InventoryAuditItemWhereUniqueInput,
        include: Optional[types.InventoryAuditItemInclude] = None
    ) -> _PrismaModelT:
        """Find a unique InventoryAuditItem record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            InventoryAuditItem filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model

        Returns
        -------
        prisma.models.InventoryAuditItem
            The found InventoryAuditItem record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryaudititem = await InventoryAuditItem.prisma().find_unique_or_raise(
            where={
                'id': 'fhdbhifae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditItemWhereInput] = None,
        cursor: Optional[types.InventoryAuditItemWhereUniqueInput] = None,
        include: Optional[types.InventoryAuditItemInclude] = None,
        order: Optional[Union[types.InventoryAuditItemOrderByInput, List[types.InventoryAuditItemOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryAuditItemScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple InventoryAuditItem records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of InventoryAuditItem records returned
        skip
            Ignore the first N results
        where
            InventoryAuditItem filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model
        order
            Order the returned InventoryAuditItem records by any field
        distinct
            Filter InventoryAuditItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.InventoryAuditItem]
            The list of all InventoryAuditItem records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 InventoryAuditItem records
        inventoryaudititems = await InventoryAuditItem.prisma().find_many(take=10)

        # find the first 5 InventoryAuditItem records ordered by the productId field
        inventoryaudititems = await InventoryAuditItem.prisma().find_many(
            take=5,
            order={
                'productId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditItemWhereInput] = None,
        cursor: Optional[types.InventoryAuditItemWhereUniqueInput] = None,
        include: Optional[types.InventoryAuditItemInclude] = None,
        order: Optional[Union[types.InventoryAuditItemOrderByInput, List[types.InventoryAuditItemOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryAuditItemScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single InventoryAuditItem record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryAuditItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model
        order
            Order the returned InventoryAuditItem records by any field
        distinct
            Filter InventoryAuditItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryAuditItem
            The first InventoryAuditItem record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryAuditItem record ordered by the systemQuantity field
        inventoryaudititem = await InventoryAuditItem.prisma().find_first(
            skip=1,
            order={
                'systemQuantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditItemWhereInput] = None,
        cursor: Optional[types.InventoryAuditItemWhereUniqueInput] = None,
        include: Optional[types.InventoryAuditItemInclude] = None,
        order: Optional[Union[types.InventoryAuditItemOrderByInput, List[types.InventoryAuditItemOrderByInput]]] = None,
        distinct: Optional[List[types.InventoryAuditItemScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single InventoryAuditItem record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            InventoryAuditItem filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model
        order
            Order the returned InventoryAuditItem records by any field
        distinct
            Filter InventoryAuditItem records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.InventoryAuditItem
            The first InventoryAuditItem record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second InventoryAuditItem record ordered by the countedQuantity field
        inventoryaudititem = await InventoryAuditItem.prisma().find_first_or_raise(
            skip=1,
            order={
                'countedQuantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.InventoryAuditItemUpdateInput,
        where: types.InventoryAuditItemWhereUniqueInput,
        include: Optional[types.InventoryAuditItemInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single InventoryAuditItem record.

        Parameters
        ----------
        data
            InventoryAuditItem record data specifying what to update
        where
            InventoryAuditItem filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model

        Returns
        -------
        prisma.models.InventoryAuditItem
            The updated InventoryAuditItem record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        inventoryaudititem = await InventoryAuditItem.prisma().update(
            where={
                'id': 'beeacgfcej',
            },
            data={
                # data to update the InventoryAuditItem record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.InventoryAuditItemWhereUniqueInput,
        data: types.InventoryAuditItemUpsertInput,
        include: Optional[types.InventoryAuditItemInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            InventoryAuditItem filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned InventoryAuditItem model

        Returns
        -------
        prisma.models.InventoryAuditItem
            The created or updated InventoryAuditItem record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        inventoryaudititem = await InventoryAuditItem.prisma().upsert(
            where={
                'id': 'bbifhdiicc',
            },
            data={
                'create': {
                    'id': 'bbifhdiicc',
                    'auditId': 'bfhdjaiejf',
                    'productId': 'bbjfijjadg',
                    'systemQuantity': 739021477,
                },
                'update': {
                    'auditId': 'bfhdjaiejf',
                    'productId': 'bbjfijjadg',
                    'systemQuantity': 739021477,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.InventoryAuditItemUpdateManyMutationInput,
        where: types.InventoryAuditItemWhereInput,
    ) -> int:
        """Update multiple InventoryAuditItem records

        Parameters
        ----------
        data
            InventoryAuditItem data to update the selected InventoryAuditItem records to
        where
            Filter to select the InventoryAuditItem records to update

        Returns
        -------
        int
            The total number of InventoryAuditItem records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all InventoryAuditItem records
        total = await InventoryAuditItem.prisma().update_many(
            data={
                'discrepancy': 1694224903
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditItemWhereInput] = None,
        cursor: Optional[types.InventoryAuditItemWhereUniqueInput] = None,
    ) -> int:
        """Count the number of InventoryAuditItem records present in the database

        Parameters
        ----------
        select
            Select the InventoryAuditItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryAuditItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryAuditItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryAuditItem.prisma().count()

        # results: prisma.types.InventoryAuditItemCountAggregateOutput
        results = await InventoryAuditItem.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.InventoryAuditItemCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditItemWhereInput] = None,
        cursor: Optional[types.InventoryAuditItemWhereUniqueInput] = None,
    ) -> types.InventoryAuditItemCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.InventoryAuditItemCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.InventoryAuditItemWhereInput] = None,
        cursor: Optional[types.InventoryAuditItemWhereUniqueInput] = None,
    ) -> Union[int, types.InventoryAuditItemCountAggregateOutput]:
        """Count the number of InventoryAuditItem records present in the database

        Parameters
        ----------
        select
            Select the InventoryAuditItem fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            InventoryAuditItem filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.InventoryAuditItemCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await InventoryAuditItem.prisma().count()

        # results: prisma.types.InventoryAuditItemCountAggregateOutput
        results = await InventoryAuditItem.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.InventoryAuditItemCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.InventoryAuditItemWhereInput] = None
    ) -> int:
        """Delete multiple InventoryAuditItem records.

        Parameters
        ----------
        where
            Optional InventoryAuditItem filter to find the records to be deleted

        Returns
        -------
        int
            The total number of InventoryAuditItem records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all InventoryAuditItem records
        total = await InventoryAuditItem.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.InventoryAuditItemScalarFieldKeys'],
        *,
        where: Optional['types.InventoryAuditItemWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.InventoryAuditItemAvgAggregateInput'] = None,
        sum: Optional['types.InventoryAuditItemSumAggregateInput'] = None,
        min: Optional['types.InventoryAuditItemMinAggregateInput'] = None,
        max: Optional['types.InventoryAuditItemMaxAggregateInput'] = None,
        having: Optional['types.InventoryAuditItemScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.InventoryAuditItemCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.InventoryAuditItemScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.InventoryAuditItemScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.InventoryAuditItemGroupByOutput']:
        """Group InventoryAuditItem records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar InventoryAuditItem fields to group records by
        where
            InventoryAuditItem filter to select records
        take
            Limit the maximum number of InventoryAuditItem records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.InventoryAuditItemGroupByOutput]
            A list of dictionaries representing the InventoryAuditItem record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group InventoryAuditItem records by id values
        # and count how many records are in each group
        results = await InventoryAuditItem.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models