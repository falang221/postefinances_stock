# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    username: _str
    email: Optional[_str] = None
    name: _str
    password: _str
    role: 'enums.UserRole'
    department: Optional[_str] = None
    refreshToken: Optional[_str] = None
    requestsCreated: Optional[List['models.Request']] = None
    requestsApproved: Optional[List['models.Request']] = None
    requestsReceived: Optional[List['models.Request']] = None
    approvals: Optional[List['models.Approval']] = None
    transactions: Optional[List['models.Transaction']] = None
    requestedStockAdjustments: Optional[List['models.StockAdjustment']] = None
    approvedStockAdjustments: Optional[List['models.StockAdjustment']] = None
    requestedStockReceipts: Optional[List['models.StockReceipt']] = None
    approvedStockReceipts: Optional[List['models.StockReceipt']] = None
    requestedPurchaseOrders: Optional[List['models.PurchaseOrder']] = None
    approvedPurchaseOrders: Optional[List['models.PurchaseOrder']] = None
    createdAudits: Optional[List['models.InventoryAudit']] = None
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Request(bases.BaseRequest):
    """Represents a Request record"""

    id: _str
    requestNumber: _str
    status: 'enums.RequestStatus'
    requesterObservations: Optional[_str] = None
    requesterId: _str
    requester: Optional['models.User'] = None
    items: Optional[List['models.RequestItem']] = None
    approvedAt: Optional[datetime.datetime] = None
    approvedById: Optional[_str] = None
    approvedBy: Optional['models.User'] = None
    receivedAt: Optional[datetime.datetime] = None
    receivedById: Optional[_str] = None
    receivedBy: Optional['models.User'] = None
    approvals: Optional[List['models.Approval']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RequestKeys']] = None,
        exclude: Optional[Iterable['types.RequestKeys']] = None,
        required: Optional[Iterable['types.RequestKeys']] = None,
        optional: Optional[Iterable['types.RequestKeys']] = None,
        relations: Optional[Mapping['types.RequestRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RequestKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Request_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Request_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Request_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Request_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Request_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Request_relational_fields:
                        raise errors.UnknownRelationalFieldError('Request', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Request / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Request',
            }
        )
        _created_partial_types.add(name)


class RequestItem(bases.BaseRequestItem):
    """Represents a RequestItem record"""

    id: _str
    requestId: _str
    request: Optional['models.Request'] = None
    productId: _str
    product: Optional['models.Product'] = None
    requestedQty: _int
    approvedQty: Optional[_int] = None
    itemDisputeReason: Optional['enums.DisputeReason'] = None
    itemDisputeComment: Optional[_str] = None
    itemDisputeStatus: 'enums.RequestItemDisputeStatus'
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RequestItemKeys']] = None,
        exclude: Optional[Iterable['types.RequestItemKeys']] = None,
        required: Optional[Iterable['types.RequestItemKeys']] = None,
        optional: Optional[Iterable['types.RequestItemKeys']] = None,
        relations: Optional[Mapping['types.RequestItemRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RequestItemKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RequestItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RequestItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RequestItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RequestItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RequestItem_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RequestItem_relational_fields:
                        raise errors.UnknownRelationalFieldError('RequestItem', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RequestItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RequestItem',
            }
        )
        _created_partial_types.add(name)


class Approval(bases.BaseApproval):
    """Represents a Approval record"""

    id: _str
    requestId: _str
    request: Optional['models.Request'] = None
    userId: _str
    user: Optional['models.User'] = None
    role: 'enums.UserRole'
    decision: 'enums.ApprovalDecision'
    comment: Optional[_str] = None
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ApprovalKeys']] = None,
        exclude: Optional[Iterable['types.ApprovalKeys']] = None,
        required: Optional[Iterable['types.ApprovalKeys']] = None,
        optional: Optional[Iterable['types.ApprovalKeys']] = None,
        relations: Optional[Mapping['types.ApprovalRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ApprovalKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Approval_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Approval_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Approval_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Approval_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Approval_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Approval_relational_fields:
                        raise errors.UnknownRelationalFieldError('Approval', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Approval / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Approval',
            }
        )
        _created_partial_types.add(name)


class Product(bases.BaseProduct):
    """Represents a Product record"""

    id: _str
    name: _str
    reference: _str
    categoryId: _str
    category: Optional['models.Category'] = None
    quantity: _int
    minStock: _int
    cost: _float
    unit: _str
    location: Optional[_str] = None
    requestItems: Optional[List['models.RequestItem']] = None
    transactions: Optional[List['models.Transaction']] = None
    stockAdjustments: Optional[List['models.StockAdjustment']] = None
    stockReceipts: Optional[List['models.StockReceipt']] = None
    purchaseOrderItems: Optional[List['models.PurchaseOrderItem']] = None
    inventoryAuditItems: Optional[List['models.InventoryAuditItem']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProductKeys']] = None,
        exclude: Optional[Iterable['types.ProductKeys']] = None,
        required: Optional[Iterable['types.ProductKeys']] = None,
        optional: Optional[Iterable['types.ProductKeys']] = None,
        relations: Optional[Mapping['types.ProductRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProductKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Product_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Product_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Product_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Product_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Product_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Product_relational_fields:
                        raise errors.UnknownRelationalFieldError('Product', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Product / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Product',
            }
        )
        _created_partial_types.add(name)


class Category(bases.BaseCategory):
    """Represents a Category record"""

    id: _str
    name: _str
    products: Optional[List['models.Product']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CategoryKeys']] = None,
        exclude: Optional[Iterable['types.CategoryKeys']] = None,
        required: Optional[Iterable['types.CategoryKeys']] = None,
        optional: Optional[Iterable['types.CategoryKeys']] = None,
        relations: Optional[Mapping['types.CategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Category_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Category_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Category_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Category_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Category_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Category_relational_fields:
                        raise errors.UnknownRelationalFieldError('Category', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Category / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Category',
            }
        )
        _created_partial_types.add(name)


class Transaction(bases.BaseTransaction):
    """Represents a Transaction record"""

    id: _str
    productId: _str
    product: Optional['models.Product'] = None
    userId: _str
    user: Optional['models.User'] = None
    type: 'enums.TransactionType'
    source: 'enums.TransactionSource'
    quantity: _int
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TransactionKeys']] = None,
        exclude: Optional[Iterable['types.TransactionKeys']] = None,
        required: Optional[Iterable['types.TransactionKeys']] = None,
        optional: Optional[Iterable['types.TransactionKeys']] = None,
        relations: Optional[Mapping['types.TransactionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TransactionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Transaction_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Transaction_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Transaction_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Transaction_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Transaction_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Transaction_relational_fields:
                        raise errors.UnknownRelationalFieldError('Transaction', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Transaction / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Transaction',
            }
        )
        _created_partial_types.add(name)


class StockAdjustment(bases.BaseStockAdjustment):
    """Represents a StockAdjustment record"""

    id: _str
    productId: _str
    product: Optional['models.Product'] = None
    quantity: _int
    type: 'enums.TransactionType'
    reason: _str
    requestedById: _str
    requestedBy: Optional['models.User'] = None
    status: 'enums.StockAdjustmentStatus'
    approvedById: Optional[_str] = None
    approvedBy: Optional['models.User'] = None
    approvedAt: Optional[datetime.datetime] = None
    dafComment: Optional[_str] = None
    inventoryAuditId: Optional[_str] = None
    inventoryAudit: Optional['models.InventoryAudit'] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.StockAdjustmentKeys']] = None,
        exclude: Optional[Iterable['types.StockAdjustmentKeys']] = None,
        required: Optional[Iterable['types.StockAdjustmentKeys']] = None,
        optional: Optional[Iterable['types.StockAdjustmentKeys']] = None,
        relations: Optional[Mapping['types.StockAdjustmentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.StockAdjustmentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _StockAdjustment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _StockAdjustment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _StockAdjustment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _StockAdjustment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _StockAdjustment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _StockAdjustment_relational_fields:
                        raise errors.UnknownRelationalFieldError('StockAdjustment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid StockAdjustment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'StockAdjustment',
            }
        )
        _created_partial_types.add(name)


class StockReceipt(bases.BaseStockReceipt):
    """Represents a StockReceipt record"""

    id: _str
    productId: _str
    product: Optional['models.Product'] = None
    quantity: _int
    supplierName: Optional[_str] = None
    batchNumber: Optional[_str] = None
    requestedById: _str
    requestedBy: Optional['models.User'] = None
    status: 'enums.StockReceiptStatus'
    approvedById: Optional[_str] = None
    approvedBy: Optional['models.User'] = None
    approvedAt: Optional[datetime.datetime] = None
    dafComment: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.StockReceiptKeys']] = None,
        exclude: Optional[Iterable['types.StockReceiptKeys']] = None,
        required: Optional[Iterable['types.StockReceiptKeys']] = None,
        optional: Optional[Iterable['types.StockReceiptKeys']] = None,
        relations: Optional[Mapping['types.StockReceiptRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.StockReceiptKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _StockReceipt_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _StockReceipt_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _StockReceipt_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _StockReceipt_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _StockReceipt_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _StockReceipt_relational_fields:
                        raise errors.UnknownRelationalFieldError('StockReceipt', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid StockReceipt / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'StockReceipt',
            }
        )
        _created_partial_types.add(name)


class PurchaseOrder(bases.BasePurchaseOrder):
    """Represents a PurchaseOrder record"""

    id: _str
    orderNumber: _str
    status: 'enums.PurchaseOrderStatus'
    requestedById: _str
    requestedBy: Optional['models.User'] = None
    approvedById: Optional[_str] = None
    approvedBy: Optional['models.User'] = None
    supplierName: Optional[_str] = None
    totalAmount: _float
    items: Optional[List['models.PurchaseOrderItem']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PurchaseOrderKeys']] = None,
        exclude: Optional[Iterable['types.PurchaseOrderKeys']] = None,
        required: Optional[Iterable['types.PurchaseOrderKeys']] = None,
        optional: Optional[Iterable['types.PurchaseOrderKeys']] = None,
        relations: Optional[Mapping['types.PurchaseOrderRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PurchaseOrderKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PurchaseOrder_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PurchaseOrder_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PurchaseOrder_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PurchaseOrder_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PurchaseOrder_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PurchaseOrder_relational_fields:
                        raise errors.UnknownRelationalFieldError('PurchaseOrder', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PurchaseOrder / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PurchaseOrder',
            }
        )
        _created_partial_types.add(name)


class PurchaseOrderItem(bases.BasePurchaseOrderItem):
    """Represents a PurchaseOrderItem record"""

    id: _str
    purchaseOrderId: _str
    purchaseOrder: Optional['models.PurchaseOrder'] = None
    productId: _str
    product: Optional['models.Product'] = None
    quantity: _int
    unitPrice: _float
    totalPrice: _float

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PurchaseOrderItemKeys']] = None,
        exclude: Optional[Iterable['types.PurchaseOrderItemKeys']] = None,
        required: Optional[Iterable['types.PurchaseOrderItemKeys']] = None,
        optional: Optional[Iterable['types.PurchaseOrderItemKeys']] = None,
        relations: Optional[Mapping['types.PurchaseOrderItemRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PurchaseOrderItemKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _PurchaseOrderItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _PurchaseOrderItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _PurchaseOrderItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _PurchaseOrderItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _PurchaseOrderItem_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _PurchaseOrderItem_relational_fields:
                        raise errors.UnknownRelationalFieldError('PurchaseOrderItem', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid PurchaseOrderItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'PurchaseOrderItem',
            }
        )
        _created_partial_types.add(name)


class Counter(bases.BaseCounter):
    """Represents a Counter record"""

    id: _str
    type: _str
    year: _int
    lastNumber: _int

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CounterKeys']] = None,
        exclude: Optional[Iterable['types.CounterKeys']] = None,
        required: Optional[Iterable['types.CounterKeys']] = None,
        optional: Optional[Iterable['types.CounterKeys']] = None,
        relations: Optional[Mapping['types.CounterRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CounterKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Counter_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Counter_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Counter_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Counter_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "Counter" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Counter / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Counter',
            }
        )
        _created_partial_types.add(name)


class InventoryAudit(bases.BaseInventoryAudit):
    """Represents a InventoryAudit record"""

    id: _str
    auditNumber: _str
    status: 'enums.InventoryAuditStatus'
    createdById: _str
    createdBy: Optional['models.User'] = None
    items: Optional[List['models.InventoryAuditItem']] = None
    stockAdjustments: Optional[List['models.StockAdjustment']] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    completedAt: Optional[datetime.datetime] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.InventoryAuditKeys']] = None,
        exclude: Optional[Iterable['types.InventoryAuditKeys']] = None,
        required: Optional[Iterable['types.InventoryAuditKeys']] = None,
        optional: Optional[Iterable['types.InventoryAuditKeys']] = None,
        relations: Optional[Mapping['types.InventoryAuditRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.InventoryAuditKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _InventoryAudit_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _InventoryAudit_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _InventoryAudit_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _InventoryAudit_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _InventoryAudit_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _InventoryAudit_relational_fields:
                        raise errors.UnknownRelationalFieldError('InventoryAudit', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid InventoryAudit / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'InventoryAudit',
            }
        )
        _created_partial_types.add(name)


class InventoryAuditItem(bases.BaseInventoryAuditItem):
    """Represents a InventoryAuditItem record"""

    id: _str
    auditId: _str
    audit: Optional['models.InventoryAudit'] = None
    productId: _str
    product: Optional['models.Product'] = None
    systemQuantity: _int
    countedQuantity: Optional[_int] = None
    discrepancy: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.InventoryAuditItemKeys']] = None,
        exclude: Optional[Iterable['types.InventoryAuditItemKeys']] = None,
        required: Optional[Iterable['types.InventoryAuditItemKeys']] = None,
        optional: Optional[Iterable['types.InventoryAuditItemKeys']] = None,
        relations: Optional[Mapping['types.InventoryAuditItemRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.InventoryAuditItemKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _InventoryAuditItem_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _InventoryAuditItem_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _InventoryAuditItem_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _InventoryAuditItem_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _InventoryAuditItem_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _InventoryAuditItem_relational_fields:
                        raise errors.UnknownRelationalFieldError('InventoryAuditItem', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid InventoryAuditItem / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'InventoryAuditItem',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'requestsCreated',
        'requestsApproved',
        'requestsReceived',
        'approvals',
        'transactions',
        'requestedStockAdjustments',
        'approvedStockAdjustments',
        'requestedStockReceipts',
        'approvedStockReceipts',
        'requestedPurchaseOrders',
        'approvedPurchaseOrders',
        'createdAudits',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('refreshToken', {
            'name': 'refreshToken',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestsCreated', {
            'name': 'requestsCreated',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Request\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestsApproved', {
            'name': 'requestsApproved',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Request\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestsReceived', {
            'name': 'requestsReceived',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Request\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvals', {
            'name': 'approvals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Approval\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactions', {
            'name': 'transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestedStockAdjustments', {
            'name': 'requestedStockAdjustments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockAdjustment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedStockAdjustments', {
            'name': 'approvedStockAdjustments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockAdjustment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestedStockReceipts', {
            'name': 'requestedStockReceipts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockReceipt\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedStockReceipts', {
            'name': 'approvedStockReceipts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockReceipt\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestedPurchaseOrders', {
            'name': 'requestedPurchaseOrders',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PurchaseOrder\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedPurchaseOrders', {
            'name': 'approvedPurchaseOrders',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PurchaseOrder\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAudits', {
            'name': 'createdAudits',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.InventoryAudit\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Request_relational_fields: Set[str] = {
        'requester',
        'items',
        'approvedBy',
        'receivedBy',
        'approvals',
    }
_Request_fields: Dict['types.RequestKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestNumber', {
            'name': 'requestNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.RequestStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('requesterObservations', {
            'name': 'requesterObservations',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requesterId', {
            'name': 'requesterId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requester', {
            'name': 'requester',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('items', {
            'name': 'items',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RequestItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedAt', {
            'name': 'approvedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedById', {
            'name': 'approvedById',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedBy', {
            'name': 'approvedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('receivedAt', {
            'name': 'receivedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('receivedById', {
            'name': 'receivedById',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('receivedBy', {
            'name': 'receivedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvals', {
            'name': 'approvals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Approval\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_RequestItem_relational_fields: Set[str] = {
        'request',
        'product',
    }
_RequestItem_fields: Dict['types.RequestItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestId', {
            'name': 'requestId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('request', {
            'name': 'request',
            'is_list': False,
            'optional': True,
            'type': 'models.Request',
            'is_relational': True,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
        ('requestedQty', {
            'name': 'requestedQty',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedQty', {
            'name': 'approvedQty',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('itemDisputeReason', {
            'name': 'itemDisputeReason',
            'is_list': False,
            'optional': True,
            'type': 'enums.DisputeReason',
            'is_relational': False,
            'documentation': None,
        }),
        ('itemDisputeComment', {
            'name': 'itemDisputeComment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('itemDisputeStatus', {
            'name': 'itemDisputeStatus',
            'is_list': False,
            'optional': False,
            'type': 'enums.RequestItemDisputeStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Approval_relational_fields: Set[str] = {
        'request',
        'user',
    }
_Approval_fields: Dict['types.ApprovalKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestId', {
            'name': 'requestId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('request', {
            'name': 'request',
            'is_list': False,
            'optional': True,
            'type': 'models.Request',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('decision', {
            'name': 'decision',
            'is_list': False,
            'optional': False,
            'type': 'enums.ApprovalDecision',
            'is_relational': False,
            'documentation': None,
        }),
        ('comment', {
            'name': 'comment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Product_relational_fields: Set[str] = {
        'category',
        'requestItems',
        'transactions',
        'stockAdjustments',
        'stockReceipts',
        'purchaseOrderItems',
        'inventoryAuditItems',
    }
_Product_fields: Dict['types.ProductKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reference', {
            'name': 'reference',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryId', {
            'name': 'categoryId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.Category',
            'is_relational': True,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('minStock', {
            'name': 'minStock',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cost', {
            'name': 'cost',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('unit', {
            'name': 'unit',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestItems', {
            'name': 'requestItems',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RequestItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactions', {
            'name': 'transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('stockAdjustments', {
            'name': 'stockAdjustments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockAdjustment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('stockReceipts', {
            'name': 'stockReceipts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockReceipt\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('purchaseOrderItems', {
            'name': 'purchaseOrderItems',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PurchaseOrderItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('inventoryAuditItems', {
            'name': 'inventoryAuditItems',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.InventoryAuditItem\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Category_relational_fields: Set[str] = {
        'products',
    }
_Category_fields: Dict['types.CategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('products', {
            'name': 'products',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Product\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Transaction_relational_fields: Set[str] = {
        'product',
        'user',
    }
_Transaction_fields: Dict['types.TransactionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.TransactionType',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': False,
            'type': 'enums.TransactionSource',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_StockAdjustment_relational_fields: Set[str] = {
        'product',
        'requestedBy',
        'approvedBy',
        'inventoryAudit',
    }
_StockAdjustment_fields: Dict['types.StockAdjustmentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.TransactionType',
            'is_relational': False,
            'documentation': None,
        }),
        ('reason', {
            'name': 'reason',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestedById', {
            'name': 'requestedById',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestedBy', {
            'name': 'requestedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StockAdjustmentStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedById', {
            'name': 'approvedById',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedBy', {
            'name': 'approvedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedAt', {
            'name': 'approvedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('dafComment', {
            'name': 'dafComment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('inventoryAuditId', {
            'name': 'inventoryAuditId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('inventoryAudit', {
            'name': 'inventoryAudit',
            'is_list': False,
            'optional': True,
            'type': 'models.InventoryAudit',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_StockReceipt_relational_fields: Set[str] = {
        'product',
        'requestedBy',
        'approvedBy',
    }
_StockReceipt_fields: Dict['types.StockReceiptKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('supplierName', {
            'name': 'supplierName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('batchNumber', {
            'name': 'batchNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestedById', {
            'name': 'requestedById',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestedBy', {
            'name': 'requestedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StockReceiptStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedById', {
            'name': 'approvedById',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedBy', {
            'name': 'approvedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedAt', {
            'name': 'approvedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('dafComment', {
            'name': 'dafComment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_PurchaseOrder_relational_fields: Set[str] = {
        'requestedBy',
        'approvedBy',
        'items',
    }
_PurchaseOrder_fields: Dict['types.PurchaseOrderKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('orderNumber', {
            'name': 'orderNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.PurchaseOrderStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestedById', {
            'name': 'requestedById',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestedBy', {
            'name': 'requestedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('approvedById', {
            'name': 'approvedById',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('approvedBy', {
            'name': 'approvedBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('supplierName', {
            'name': 'supplierName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalAmount', {
            'name': 'totalAmount',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('items', {
            'name': 'items',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.PurchaseOrderItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_PurchaseOrderItem_relational_fields: Set[str] = {
        'purchaseOrder',
        'product',
    }
_PurchaseOrderItem_fields: Dict['types.PurchaseOrderItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('purchaseOrderId', {
            'name': 'purchaseOrderId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('purchaseOrder', {
            'name': 'purchaseOrder',
            'is_list': False,
            'optional': True,
            'type': 'models.PurchaseOrder',
            'is_relational': True,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('unitPrice', {
            'name': 'unitPrice',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalPrice', {
            'name': 'totalPrice',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Counter_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_Counter_fields: Dict['types.CounterKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('year', {
            'name': 'year',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastNumber', {
            'name': 'lastNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_InventoryAudit_relational_fields: Set[str] = {
        'createdBy',
        'items',
        'stockAdjustments',
    }
_InventoryAudit_fields: Dict['types.InventoryAuditKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auditNumber', {
            'name': 'auditNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.InventoryAuditStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdById', {
            'name': 'createdById',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('items', {
            'name': 'items',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.InventoryAuditItem\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('stockAdjustments', {
            'name': 'stockAdjustments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StockAdjustment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completedAt', {
            'name': 'completedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_InventoryAuditItem_relational_fields: Set[str] = {
        'audit',
        'product',
    }
_InventoryAuditItem_fields: Dict['types.InventoryAuditItemKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auditId', {
            'name': 'auditId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('audit', {
            'name': 'audit',
            'is_list': False,
            'optional': True,
            'type': 'models.InventoryAudit',
            'is_relational': True,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
        ('systemQuantity', {
            'name': 'systemQuantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('countedQuantity', {
            'name': 'countedQuantity',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('discrepancy', {
            'name': 'discrepancy',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Request)
model_rebuild(RequestItem)
model_rebuild(Approval)
model_rebuild(Product)
model_rebuild(Category)
model_rebuild(Transaction)
model_rebuild(StockAdjustment)
model_rebuild(StockReceipt)
model_rebuild(PurchaseOrder)
model_rebuild(PurchaseOrderItem)
model_rebuild(Counter)
model_rebuild(InventoryAudit)
model_rebuild(InventoryAuditItem)
